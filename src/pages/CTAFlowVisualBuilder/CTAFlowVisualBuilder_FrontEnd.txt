Folder and File Content Report
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\CTAFlowLogs.jsx 
====================================================== 
 
import React, { useEffect, useState } from "react";
import axiosClient from "../../api/axiosClient";
import { Card } from "../../components/ui/card";
import { Table, Thead, Tbody, Tr, Th, Td } from "../../components/ui/table";
import { format } from "date-fns";

const CTAFlowLogs = () => {
  const [logs, setLogs] = useState([]);

  useEffect(() => {
    axiosClient.get("/tracking/flow-clicks").then(res => {
      setLogs(res.data);
    });
  }, []);

  return (
    <div className="p-6">
      <h2 className="text-2xl font-bold mb-4">CTA Flow Click Logs</h2>
      <Card className="overflow-x-auto">
        <Table>
          <Thead>
            <Tr>
              <Th>Date</Th>
              <Th>Recipient</Th>
              <Th>Button</Th>
              <Th>Template</Th>
              <Th>Step ID</Th>
              <Th>Follow-Up</Th>
            </Tr>
          </Thead>
          <Tbody>
            {logs.map(log => (
              <Tr key={log.id}>
                <Td>
                  {format(new Date(log.clickedAt), "dd MMM yyyy hh:mm a")}
                </Td>
                <Td>{log.contactPhone}</Td>
                <Td>{log.buttonText}</Td>
                <Td>{log.templateId}</Td>
                <Td className="text-xs">{log.stepId}</Td>
                <Td>
                  {log.followUpSent ? (
                    <span className="text-green-600 font-semibold">‚úÖ Yes</span>
                  ) : (
                    <span className="text-gray-500">‚Äî</span>
                  )}
                </Td>
              </Tr>
            ))}
          </Tbody>
        </Table>
      </Card>
    </div>
  );
};

export default CTAFlowLogs;
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\CTAFlowManager.jsx 
====================================================== 
 
import React, { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import axiosClient from "../../api/axiosClient";
import { toast } from "react-toastify";

export default function CTAFlowManager() {
  const [flows, setFlows] = useState([]);
  const [activeTab, setActiveTab] = useState("draft");
  const navigate = useNavigate();

  const fetchFlows = async (tab = "draft") => {
    try {
      const endpoint =
        tab === "published" ? "/cta-flow/all-published" : "/cta-flow/all-draft";

      const res = await axiosClient.get(endpoint);
      setFlows(Array.isArray(res.data) ? res.data : [res.data]);
    } catch (err) {
      toast.error("‚ùå Failed to load flows");
      console.error(err);
    }
  };

  useEffect(() => {
    fetchFlows("draft");
  }, []);

  const handleDelete = async id => {
    const confirm = window.confirm(
      "Are you sure you want to delete this flow?"
    );
    if (!confirm) return;

    try {
      await axiosClient.delete(`/cta-flow/delete/${id}`);
      toast.success("‚úÖ Flow deleted successfully");
      fetchFlows(activeTab);
    } catch (err) {
      toast.error("‚ùå Failed to delete flow");
      console.error(err);
    }
  };

  const formatDate = date => {
    const d = new Date(date);
    return d.toLocaleDateString("en-IN", {
      day: "2-digit",
      month: "short",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  return (
    <div className="p-6">
      {/* Header */}
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">
            üß© CTA Flow Manager
          </h1>
          <p className="text-sm text-gray-500">
            Create, edit, and manage your visual flows.
          </p>
        </div>
        <button
          onClick={() => navigate("/app/cta-flow/visual-builder")}
          className="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-md shadow"
        >
          ‚ûï New Flow
        </button>
      </div>

      {/* Tabs */}
      <div className="flex gap-6 border-b mb-4 text-sm font-medium">
        {["draft", "published"].map(tab => (
          <button
            key={tab}
            className={`pb-2 transition-all ${
              activeTab === tab
                ? "text-purple-600 border-b-2 border-purple-600"
                : "text-gray-500 hover:text-purple-600"
            }`}
            onClick={() => {
              setActiveTab(tab);
              fetchFlows(tab);
            }}
          >
            {tab === "draft" ? "üìù Draft Flows" : "‚úÖ Published Flows"}
          </button>
        ))}
      </div>

      {/* Table */}
      {flows.length === 0 ? (
        <div className="text-gray-500 text-center py-10">
          No {activeTab} flows found.
        </div>
      ) : (
        <div className="bg-white rounded-xl shadow overflow-hidden">
          <table className="w-full text-sm text-left">
            <thead className="bg-gray-50 border-b text-gray-500 uppercase text-xs tracking-wide">
              <tr>
                <th className="px-4 py-3">Flow Name</th>
                <th className="px-4 py-3">Status</th>
                <th className="px-4 py-3">Last Modified</th>
                <th className="px-4 py-3 text-right">Actions</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-100">
              {flows.map(flow => (
                <tr
                  key={flow.id}
                  className="hover:bg-gray-50 transition-all duration-150"
                >
                  <td className="px-4 py-3 font-medium text-gray-800">
                    {flow.flowName}
                  </td>
                  <td className="px-4 py-3">
                    {flow.isPublished ? (
                      <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-700">
                        ‚úÖ Published
                      </span>
                    ) : (
                      <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-700">
                        üìù Draft
                      </span>
                    )}
                  </td>
                  <td className="px-4 py-3 text-gray-600">
                    {formatDate(flow.updatedAt || flow.createdAt)}
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex justify-end gap-2">
                      <button
                        onClick={() =>
                          navigate(
                            `/app/cta-flow-builder?id=${flow.id}&mode=view`
                          )
                        }
                        className="text-blue-600 hover:underline text-xs"
                      >
                        üëÅÔ∏è View
                      </button>
                      {!flow.isPublished && (
                        <button
                          onClick={() =>
                            navigate(
                              `/app/cta-flow-builder?id=${flow.id}&mode=edit`
                            )
                          }
                          className="text-yellow-600 hover:underline text-xs"
                        >
                          ‚úèÔ∏è Edit
                        </button>
                      )}
                      <button
                        onClick={() => handleDelete(flow.id)}
                        className="text-red-600 hover:underline text-xs"
                      >
                        üóëÔ∏è Delete
                      </button>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\ctaFlowVisualApi.js 
====================================================== 
 
import axiosClient from "../../api/axiosClient";

// ‚úÖ FINAL version with Index support for buttons
export async function saveVisualFlow(payload) {
  const safeNodes = (payload.Nodes || []).map(node => {
    return {
      Id: node.Id || "",
      TemplateName: node.TemplateName || "",
      TemplateType: node.TemplateType || "text_template",
      MessageBody: node.MessageBody || "",
      PositionX: node.PositionX ?? 0,
      PositionY: node.PositionY ?? 0,
      TriggerButtonText: node.TriggerButtonText || "",
      TriggerButtonType: node.TriggerButtonType || "cta",
      Buttons: (node.Buttons || []).map((btn, idx) => ({
        Text: btn.Text || "",
        Type: btn.Type || "",
        SubType: btn.SubType || "",
        Value: btn.Value || "",
        TargetNodeId: btn.TargetNodeId || null,
        Index: typeof btn.Index === "number" ? btn.Index : idx, // ‚úÖ preserve Index
      })),
    };
  });

  const safeEdges = (payload.Edges || []).map(edge => ({
    FromNodeId: edge.FromNodeId || "",
    ToNodeId: edge.ToNodeId || "",
    SourceHandle: edge.SourceHandle || "",
  }));

  const fixedPayload = {
    FlowName: payload.FlowName || "Untitled",
    IsPublished: payload.IsPublished ?? false,
    Nodes: safeNodes,
    Edges: safeEdges,
  };

  console.log("üì§ Sending flow to API:", fixedPayload);
  const response = await axiosClient.post(
    "/cta-flow/save-visual",
    fixedPayload
  );
  return response.data;
}

// üì• Load a specific visual flow by ID
export async function getVisualFlowById(flowId) {
  const res = await axiosClient.get(`/cta-flow/by-id/${flowId}`);
  return res.data;
}

// import axiosClient from "../../api/axiosClient";
// // Removed: import { v4 as uuidv4 } from "uuid"; // Not used

// // ‚úÖ FINAL version with UUID fallback for node.Id
// // ‚úÖ Accept the full payload object
// export async function saveVisualFlow(payload) {
//   const safeNodes = (payload.Nodes || []).map(node => {
//     // Removed: const data = node.data || {}; // Not used
//     return {
//       Id: node.Id || "",
//       TemplateName: node.TemplateName || "",
//       TemplateType: node.TemplateType || "text_template",
//       MessageBody: node.MessageBody || "",
//       PositionX: node.PositionX ?? 0,
//       PositionY: node.PositionY ?? 0,
//       TriggerButtonText: node.TriggerButtonText || "",
//       TriggerButtonType: node.TriggerButtonType || "cta",
//       Buttons: (node.Buttons || []).map(btn => ({
//         Text: btn.Text || "",
//         Type: btn.Type || "",
//         SubType: btn.SubType || "",
//         Value: btn.Value || "",
//         TargetNodeId: btn.TargetNodeId || null,
//       })),
//     };
//   });

//   const safeEdges = (payload.Edges || []).map(edge => ({
//     FromNodeId: edge.FromNodeId || "",
//     ToNodeId: edge.ToNodeId || "",
//     SourceHandle: edge.SourceHandle || "",
//   }));

//   const fixedPayload = {
//     FlowName: payload.FlowName || "Untitled",
//     IsPublished: payload.IsPublished ?? false,
//     Nodes: safeNodes,
//     Edges: safeEdges,
//   };

//   console.log("üì§ Sending minimal flow to API:", fixedPayload);
//   const response = await axiosClient.post(
//     "/cta-flow/save-visual",
//     fixedPayload
//   );
//   return response.data;
// }

// // üì• Load a specific visual flow by ID
// export async function getVisualFlowById(flowId) {
//   const res = await axiosClient.get(`/cta-flow/by-id/${flowId}`);
//   return res.data;
// }

// import axiosClient from "../../api/axiosClient";
// import { v4 as uuidv4 } from "uuid"; // ‚úÖ Ensure UUID generator is imported

// // ‚úÖ FINAL version with UUID fallback for node.Id
// // ‚úÖ Accept the full payload object
// export async function saveVisualFlow(payload) {
//   const safeNodes = (payload.Nodes || []).map(node => {
//     const data = node.data || {};
//     return {
//       Id: node.Id || "",
//       TemplateName: node.TemplateName || "",
//       TemplateType: node.TemplateType || "text_template",
//       MessageBody: node.MessageBody || "",
//       PositionX: node.PositionX ?? 0,
//       PositionY: node.PositionY ?? 0,
//       TriggerButtonText: node.TriggerButtonText || "",
//       TriggerButtonType: node.TriggerButtonType || "cta",
//       Buttons: (node.Buttons || []).map(btn => ({
//         Text: btn.Text || "",
//         Type: btn.Type || "",
//         SubType: btn.SubType || "",
//         Value: btn.Value || "",
//         TargetNodeId: btn.TargetNodeId || null,
//       })),
//     };
//   });

//   const safeEdges = (payload.Edges || []).map(edge => ({
//     FromNodeId: edge.FromNodeId || "",
//     ToNodeId: edge.ToNodeId || "",
//     SourceHandle: edge.SourceHandle || "",
//   }));

//   const fixedPayload = {
//     FlowName: payload.FlowName || "Untitled",
//     IsPublished: payload.IsPublished ?? false,
//     Nodes: safeNodes,
//     Edges: safeEdges,
//   };

//   console.log("üì§ Sending minimal flow to API:", fixedPayload);
//   const response = await axiosClient.post(
//     "/cta-flow/save-visual",
//     fixedPayload
//   );
//   return response.data;
// }

// // üì• Load a specific visual flow by ID
// export async function getVisualFlowById(flowId) {
//   const res = await axiosClient.get(`/cta-flow/by-id/${flowId}`);
//   return res.data;
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\CTAFlowVisualBuilder.jsx 
====================================================== 
 
import React, {
  useCallback,
  useState,
  useEffect,
  useMemo,
  useRef,
} from "react";
import {
  ReactFlow,
  ReactFlowProvider,
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  addEdge,
  MarkerType,
  ConnectionMode,
  useReactFlow,
} from "@xyflow/react";
import "@xyflow/react/dist/style.css";
import { Eye, Minus } from "lucide-react";
import { useSearchParams, useNavigate } from "react-router-dom";
import TemplatePickerModal from "./components/TemplatePickerModal";
import FlowNodeBubble from "./components/FlowNodeBubble";
import { saveVisualFlow, getVisualFlowById } from "./ctaFlowVisualApi";
import { v4 as uuidv4 } from "uuid";
import { toast } from "react-toastify";
import dagre from "dagre";

// NEW: custom edge that flips label vertically when space is tight
import SmartLabeledEdge from "./components/edges/SmartLabeledEdge";

const GRID = 16;
const NODE_DEFAULT = { width: 260, height: 140 }; // safe defaults for dagre when sizes are unknown

function CTAFlowVisualBuilderInner() {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const nodesRef = useRef([]);
  const [showPicker, setShowPicker] = useState(false);
  const [flowName, setFlowName] = useState("");
  const flowNameRef = useRef(null);
  const [showMiniMap, setShowMiniMap] = useState(false);
  const [readonly, setReadonly] = useState(false);
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const { fitView, zoomIn, zoomOut } = useReactFlow();
  const mode = searchParams.get("mode");
  const flowId = searchParams.get("id");
  const visualDebug = true;

  useEffect(() => {
    nodesRef.current = [...nodes];
  }, [nodes]);

  // -------- Node helpers --------
  const handleDeleteNode = useCallback(
    nodeId => {
      if (readonly) return;
      setNodes(nds => nds.filter(n => n.id !== nodeId));
      setEdges(eds =>
        eds.filter(e => e.source !== nodeId && e.target !== nodeId)
      );
    },
    [readonly, setNodes, setEdges]
  );

  const handleNodeDataChange = useCallback(
    (nodeId, newData) => {
      setNodes(nds =>
        nds.map(n =>
          n.id === nodeId ? { ...n, data: { ...n.data, ...newData } } : n
        )
      );
    },
    [setNodes]
  );

  const nodeTypes = useMemo(
    () => ({
      customBubble: props => (
        <FlowNodeBubble
          {...props}
          onDelete={handleDeleteNode}
          onDataChange={newData => handleNodeDataChange(props.id, newData)}
          readonly={readonly}
          visualDebug={visualDebug}
        />
      ),
    }),
    [handleDeleteNode, readonly, visualDebug, handleNodeDataChange]
  );

  // NEW: register custom edge
  const edgeTypes = useMemo(() => ({ smart: SmartLabeledEdge }), []);

  // -------- Load / Bootstrap --------
  useEffect(() => {
    const load = async () => {
      if (mode === "edit" || mode === "view") {
        try {
          const data = await getVisualFlowById(flowId);

          const builtNodes = (data.nodes || []).map((node, index) => ({
            id: node.id,
            type: "customBubble",
            position: {
              x: node.positionX ?? 120 + index * 120,
              y: node.positionY ?? 150 + (index % 5) * 60,
            },
            data: {
              templateName: node.templateName,
              templateType: node.templateType,
              messageBody: node.messageBody,
              triggerButtonText: node.triggerButtonText || "",
              triggerButtonType: node.triggerButtonType || "cta",
              requiredTag: node.requiredTag || "",
              requiredSource: node.requiredSource || "",
              buttons: (node.buttons || []).map((btn, i) => ({
                text: btn.text,
                type: btn.type,
                subType: btn.subType,
                value: btn.value,
                targetNodeId: btn.targetNodeId || null,
                index: typeof btn.index === "number" ? btn.index : i,
              })),
            },
          }));

          const builtEdges = (data.edges || []).map(edge => ({
            id: `e-${edge.fromNodeId}-${edge.toNodeId}-${
              edge.sourceHandle || "h"
            }`,
            source: edge.fromNodeId,
            target: edge.toNodeId,
            sourceHandle: edge.sourceHandle || null, // equals button text
            type: "smart", // <-- use custom edge
            animated: true,
            style: { stroke: "#9333ea" },
            markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
            label: edge.sourceHandle || "", // show button text on edge
          }));

          const nodesWithIncoming = new Set(builtEdges.map(e => e.target));
          const nodesWithWarnings = builtNodes.map(node => ({
            ...node,
            data: {
              ...node.data,
              isUnreachable: false,
              hasNoIncoming: !nodesWithIncoming.has(node.id),
            },
          }));

          setNodes(nodesWithWarnings);
          setEdges(builtEdges);
          setFlowName(data.flowName || "Untitled Flow");
          if (mode === "view") setReadonly(true);

          setTimeout(() => fitView({ padding: 0.2 }), 50);
        } catch {
          toast.error("‚ùå Failed to load flow");
        }
      } else {
        setNodes([]);
        setEdges([]);
        setFlowName("Untitled Flow");
        setReadonly(false);
        setTimeout(() => fitView({ padding: 0.2 }), 50);
      }
    };

    load();
  }, [flowId, mode, setNodes, setEdges, fitView]);

  // -------- Template add --------
  const handleTemplateSelect = ({ name, type, body, buttons = [] }) => {
    const id = uuidv4();
    const newNode = {
      id,
      position: { x: Math.random() * 400 + 100, y: Math.random() * 300 + 100 },
      type: "customBubble",
      data: {
        templateName: name || "Untitled",
        templateType: type || "text_template",
        messageBody: body || "Message body preview...",
        triggerButtonText: buttons[0]?.text || "",
        triggerButtonType: "cta",
        buttons: buttons.map((btn, idx) => ({
          text: btn.text || "",
          type: btn.type || "QUICK_REPLY",
          subType: btn.subType || "",
          value: btn.parameterValue || "",
          targetNodeId: null,
          index: idx,
        })),
      },
    };
    setNodes(nds => [...nds, newNode]);
    setShowPicker(false);
    toast.success(
      `‚úÖ Step added with ${type?.replace("_", " ") || "template"}`
    );
    setTimeout(() => fitView({ padding: 0.2 }), 50);
  };

  // -------- Connection policy (pro-grade) --------
  const isValidConnection = useCallback(
    params => {
      if (!params?.source || !params?.sourceHandle) return false; // require handle‚Üíhandle
      // Only one edge per (source, sourceHandle)
      const duplicate = edges.some(
        e =>
          e.source === params.source && e.sourceHandle === params.sourceHandle
      );
      return !duplicate;
    },
    [edges]
  );

  const onConnect = useCallback(
    params => {
      if (readonly) return;

      const label = params.sourceHandle || "";

      // Visual edge (custom)
      setEdges(eds =>
        addEdge(
          {
            ...params,
            id: uuidv4(),
            type: "smart",
            animated: true,
            style: { stroke: "#9333ea" },
            markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
            label,
          },
          eds
        )
      );

      // Semantic link: tie edge to the specific button on source node
      setNodes(nds =>
        nds.map(node => {
          if (node.id !== params.source) return node;

          const sourceHandle = params.sourceHandle || "";
          let updatedButtons = [...(node.data.buttons || [])];

          const idxByHandle = updatedButtons.findIndex(
            b =>
              (b.text || "").toLowerCase().trim() ===
              sourceHandle.toLowerCase().trim()
          );

          if (idxByHandle >= 0) {
            updatedButtons[idxByHandle] = {
              ...updatedButtons[idxByHandle],
              targetNodeId: params.target,
            };
          } else {
            const idxFirstUnlinked = updatedButtons.findIndex(
              b => !b.targetNodeId
            );
            if (idxFirstUnlinked >= 0) {
              updatedButtons[idxFirstUnlinked] = {
                ...updatedButtons[idxFirstUnlinked],
                targetNodeId: params.target,
              };
            }
          }
          return { ...node, data: { ...node.data, buttons: updatedButtons } };
        })
      );
    },
    [readonly, setEdges, setNodes]
  );

  // -------- Keyboard UX --------
  useEffect(() => {
    const onKey = e => {
      if (readonly) return;
      if (e.key === "Delete" || e.key === "Backspace") {
        setNodes(nds => nds.filter(n => !n.selected));
        setEdges(eds => eds.filter(ed => !ed.selected));
      }
      if (e.key === "Escape") {
        setNodes(nds => nds.map(n => ({ ...n, selected: false })));
        setEdges(eds => eds.map(ed => ({ ...ed, selected: false })));
      }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [readonly, setNodes, setEdges]);

  // -------- Auto-layout (dagre) --------
  const applyLayout = useCallback(
    (direction = "LR") => {
      const g = new dagre.graphlib.Graph();
      g.setGraph({
        rankdir: direction, // LR (left->right) or TB (top->bottom)
        nodesep: 50,
        ranksep: 90,
        marginx: 20,
        marginy: 20,
      });
      g.setDefaultEdgeLabel(() => ({}));

      nodes.forEach(n => {
        const width = n?.measured?.width || NODE_DEFAULT.width;
        const height = n?.measured?.height || NODE_DEFAULT.height;
        g.setNode(n.id, { width, height });
      });
      edges.forEach(e => g.setEdge(e.source, e.target));

      dagre.layout(g);

      const laidOut = nodes.map(n => {
        const { x, y } = g.node(n.id);
        const width = n?.measured?.width || NODE_DEFAULT.width;
        const height = n?.measured?.height || NODE_DEFAULT.height;
        return {
          ...n,
          position: { x: x - width / 2, y: y - height / 2 },
        };
      });

      setNodes(laidOut);
      setTimeout(() => fitView({ padding: 0.2 }), 50);
    },
    [nodes, edges, setNodes, fitView]
  );

  // -------- Save --------
  const handleSave = async isPublished => {
    try {
      const transformedNodes = nodes
        .filter(n => n?.data?.templateName)
        .map(node => ({
          Id: node.id || uuidv4(),
          TemplateName: node?.data?.templateName || "Untitled",
          TemplateType: node?.data?.templateType || "text_template",
          MessageBody: node?.data?.messageBody || "",
          PositionX: node.position?.x || 0,
          PositionY: node.position?.y || 0,
          TriggerButtonText: node?.data?.triggerButtonText || "",
          TriggerButtonType: node?.data?.triggerButtonType || "cta",
          RequiredTag: node?.data?.requiredTag || "",
          RequiredSource: node?.data?.requiredSource || "",
          Buttons: (node?.data?.buttons || [])
            .filter(btn => (btn.text || "").trim().length > 0)
            .map((btn, idx) => ({
              Text: (btn.text || "").trim(),
              Type: btn.type || "QUICK_REPLY",
              SubType: btn.subType || "",
              Value: btn.value || "",
              TargetNodeId: btn.targetNodeId || null,
              Index: typeof btn.index === "number" ? btn.index : idx,
            })),
        }));

      const transformedEdges = edges.map(edge => ({
        FromNodeId: edge.source,
        ToNodeId: edge.target,
        SourceHandle: edge.sourceHandle || "",
      }));

      const payload = {
        FlowName: flowName || "Untitled",
        IsPublished: isPublished ?? false,
        Nodes: transformedNodes,
        Edges: transformedEdges,
      };

      console.log("üì§ Final Payload to POST:", payload);
      await saveVisualFlow(payload);
      toast.success("‚úÖ Flow saved successfully");
    } catch (error) {
      console.error("‚ùå Save flow failed: ", error);
      toast.error("‚ùå Failed to save flow");
    }
  };

  // -------- Default edge appearance --------
  const defaultEdgeOptions = useMemo(
    () => ({
      type: "smart", // <-- use custom smart edge by default
      animated: true,
      style: { stroke: "#9333ea" },
      markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
    }),
    []
  );

  return (
    <div className="p-6">
      {/* Header */}
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl font-bold text-purple-700">
          üß† CTA Flow Visual Builder
        </h2>

        {!readonly && (
          <div className="flex items-center gap-2 flex-wrap">
            <input
              id="flowName"
              name="flowName"
              ref={flowNameRef}
              value={flowName}
              onChange={e => setFlowName(e.target.value)}
              placeholder="Add flow name"
              className="border border-gray-300 px-3 py-2 rounded-md shadow-sm text-sm"
            />
            <button
              onClick={() => setShowPicker(true)}
              className="bg-purple-600 text-white px-4 py-2 rounded shadow hover:bg-purple-700 text-sm"
            >
              ‚ûï Add Step
            </button>
            <button
              onClick={() => navigate("/app/cta-flow/flow-manager")}
              className="bg-white border border-purple-600 text-purple-700 font-medium text-sm px-4 py-2 rounded-md shadow-sm hover:bg-purple-50"
            >
              ‚Ü©Ô∏è Manage All Flows
            </button>
          </div>
        )}
      </div>

      {/* Canvas */}
      <div className="h-[70vh] border rounded-xl bg-gray-50 relative">
        {/* Minimap + tools */}
        <div className="absolute bottom-5 right-4 z-50 flex gap-2">
          <button
            onClick={() => setShowMiniMap(prev => !prev)}
            className="bg-purple-600 text-white p-2 rounded-full shadow hover:bg-purple-700"
            title={showMiniMap ? "Hide MiniMap" : "Show MiniMap"}
          >
            {showMiniMap ? <Minus size={15} /> : <Eye size={15} />}
          </button>

          <div className="flex items-center gap-2 bg-white/90 px-2 py-1 rounded-full border">
            <button
              onClick={() => fitView({ padding: 0.2 })}
              className="text-xs px-2 py-1 rounded hover:bg-gray-100"
              title="Fit"
            >
              Fit
            </button>
            <button
              onClick={() => zoomIn()}
              className="text-xs px-2 py-1 rounded hover:bg-gray-100"
              title="Zoom In"
            >
              +
            </button>
            <button
              onClick={() => zoomOut()}
              className="text-xs px-2 py-1 rounded hover:bg-gray-100"
              title="Zoom Out"
            >
              ‚àí
            </button>
            {!readonly && (
              <>
                <button
                  onClick={() => applyLayout("LR")}
                  className="text-xs px-2 py-1 rounded hover:bg-gray-100"
                  title="Auto-layout (Left‚ÜíRight)"
                >
                  Auto LR
                </button>
                <button
                  onClick={() => applyLayout("TB")}
                  className="text-xs px-2 py-1 rounded hover:bg-gray-100"
                  title="Auto-layout (Top‚ÜíBottom)"
                >
                  Auto TB
                </button>
              </>
            )}
          </div>
        </div>

        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          onEdgeClick={(e, edge) => {
            if (!readonly) setEdges(eds => eds.filter(ed => ed.id !== edge.id));
          }}
          nodeTypes={nodeTypes}
          edgeTypes={edgeTypes} // <-- register custom edge
          fitView
          fitViewOptions={{ padding: 0.2 }}
          defaultEdgeOptions={defaultEdgeOptions}
          connectionMode={ConnectionMode.Strict}
          isValidConnection={isValidConnection}
          snapToGrid
          snapGrid={[GRID, GRID]}
          panOnScroll
          zoomOnPinch
          panOnDrag={[1, 2]}
          selectionOnDrag
          nodesDraggable={!readonly}
          nodesConnectable={!readonly}
          elementsSelectable={!readonly}
        >
          {showMiniMap && (
            <MiniMap
              nodeColor="#9333ea"
              nodeStrokeWidth={2}
              maskColor="rgba(255,255,255,0.6)"
            />
          )}
          <Controls />
          <Background variant="dots" gap={GRID} size={1} />
        </ReactFlow>
      </div>

      {/* Footer actions */}
      {!readonly && (
        <div className="mt-6 flex gap-4">
          <button
            onClick={() => handleSave(false)}
            className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm"
          >
            üíæ Save Draft
          </button>
          <button
            onClick={() => handleSave(true)}
            className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-sm"
          >
            üöÄ Publish Flow
          </button>
        </div>
      )}

      <TemplatePickerModal
        open={showPicker}
        onClose={() => setShowPicker(false)}
        onSelect={handleTemplateSelect}
      />
    </div>
  );
}

export default function CTAFlowVisualBuilder() {
  return (
    <ReactFlowProvider>
      <CTAFlowVisualBuilderInner />
    </ReactFlowProvider>
  );
}

// import React, {
//   useCallback,
//   useState,
//   useEffect,
//   useMemo,
//   useRef,
// } from "react";
// import {
//   ReactFlow,
//   ReactFlowProvider,
//   Background,
//   Controls,
//   MiniMap,
//   useNodesState,
//   useEdgesState,
//   addEdge,
//   MarkerType,
//   ConnectionMode,
//   useReactFlow,
// } from "@xyflow/react";
// import "@xyflow/react/dist/style.css";
// import { Eye, Minus } from "lucide-react";
// import { useSearchParams, useNavigate } from "react-router-dom";
// import TemplatePickerModal from "./components/TemplatePickerModal";
// import FlowNodeBubble from "./components/FlowNodeBubble";
// import { saveVisualFlow, getVisualFlowById } from "./ctaFlowVisualApi";
// import { v4 as uuidv4 } from "uuid";
// import { toast } from "react-toastify";
// import dagre from "dagre";

// const GRID = 16;
// const NODE_DEFAULT = { width: 260, height: 140 }; // safe defaults for dagre when sizes are unknown

// function CTAFlowVisualBuilderInner() {
//   const [nodes, setNodes, onNodesChange] = useNodesState([]);
//   const [edges, setEdges, onEdgesChange] = useEdgesState([]);
//   const nodesRef = useRef([]);
//   const [showPicker, setShowPicker] = useState(false);
//   const [flowName, setFlowName] = useState("");
//   const flowNameRef = useRef(null);
//   const [showMiniMap, setShowMiniMap] = useState(false);
//   const [readonly, setReadonly] = useState(false);
//   const [searchParams] = useSearchParams();
//   const navigate = useNavigate();
//   const { fitView, zoomIn, zoomOut } = useReactFlow();
//   const mode = searchParams.get("mode");
//   const flowId = searchParams.get("id");
//   const visualDebug = true;

//   useEffect(() => {
//     nodesRef.current = [...nodes];
//   }, [nodes]);

//   // -------- Node helpers --------
//   const handleDeleteNode = useCallback(
//     nodeId => {
//       if (readonly) return;
//       setNodes(nds => nds.filter(n => n.id !== nodeId));
//       setEdges(eds =>
//         eds.filter(e => e.source !== nodeId && e.target !== nodeId)
//       );
//     },
//     [readonly, setNodes, setEdges]
//   );

//   const handleNodeDataChange = useCallback(
//     (nodeId, newData) => {
//       setNodes(nds =>
//         nds.map(n =>
//           n.id === nodeId ? { ...n, data: { ...n.data, ...newData } } : n
//         )
//       );
//     },
//     [setNodes]
//   );

//   const nodeTypes = useMemo(
//     () => ({
//       customBubble: props => (
//         <FlowNodeBubble
//           {...props}
//           onDelete={handleDeleteNode}
//           onDataChange={newData => handleNodeDataChange(props.id, newData)}
//           readonly={readonly}
//           visualDebug={visualDebug}
//         />
//       ),
//     }),
//     [handleDeleteNode, readonly, visualDebug, handleNodeDataChange]
//   );

//   // -------- Load / Bootstrap --------
//   useEffect(() => {
//     const load = async () => {
//       if (mode === "edit" || mode === "view") {
//         try {
//           const data = await getVisualFlowById(flowId);

//           const builtNodes = (data.nodes || []).map((node, index) => ({
//             id: node.id,
//             type: "customBubble",
//             position: {
//               x: node.positionX ?? 120 + index * 120,
//               y: node.positionY ?? 150 + (index % 5) * 60,
//             },
//             data: {
//               templateName: node.templateName,
//               templateType: node.templateType,
//               messageBody: node.messageBody,
//               triggerButtonText: node.triggerButtonText || "",
//               triggerButtonType: node.triggerButtonType || "cta",
//               requiredTag: node.requiredTag || "",
//               requiredSource: node.requiredSource || "",
//               // keep button order and include index if backend returned one
//               buttons: (node.buttons || []).map((btn, i) => ({
//                 text: btn.text,
//                 type: btn.type,
//                 subType: btn.subType,
//                 value: btn.value,
//                 targetNodeId: btn.targetNodeId || null,
//                 index: typeof btn.index === "number" ? btn.index : i,
//               })),
//             },
//           }));

//           const builtEdges = (data.edges || []).map(edge => ({
//             id: `e-${edge.fromNodeId}-${edge.toNodeId}-${
//               edge.sourceHandle || "h"
//             }`,
//             source: edge.fromNodeId,
//             target: edge.toNodeId,
//             sourceHandle: edge.sourceHandle || null, // equals button text
//             type: "smoothstep",
//             animated: true,
//             style: { stroke: "#9333ea" },
//             markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
//             label: edge.sourceHandle || "", // <‚Äî show button text on edge
//             labelStyle: { fontSize: 10, fill: "#4b5563" },
//             labelBgPadding: [4, 2],
//             labelBgBorderRadius: 4,
//             labelBgStyle: { fill: "#ffffff" },
//           }));

//           // Informational flag
//           const nodesWithIncoming = new Set(builtEdges.map(e => e.target));
//           const nodesWithWarnings = builtNodes.map(node => ({
//             ...node,
//             data: {
//               ...node.data,
//               isUnreachable: false,
//               hasNoIncoming: !nodesWithIncoming.has(node.id),
//             },
//           }));

//           setNodes(nodesWithWarnings);
//           setEdges(builtEdges);
//           setFlowName(data.flowName || "Untitled Flow");
//           if (mode === "view") setReadonly(true);

//           // Fit after initial load
//           setTimeout(() => fitView({ padding: 0.2 }), 50);
//         } catch {
//           toast.error("‚ùå Failed to load flow");
//         }
//       } else {
//         setNodes([]);
//         setEdges([]);
//         setFlowName("Untitled Flow");
//         setReadonly(false);
//         setTimeout(() => fitView({ padding: 0.2 }), 50);
//       }
//     };

//     load();
//   }, [flowId, mode, setNodes, setEdges, fitView]);

//   // -------- Template add --------
//   const handleTemplateSelect = ({ name, type, body, buttons = [] }) => {
//     const id = uuidv4();
//     const newNode = {
//       id,
//       position: { x: Math.random() * 400 + 100, y: Math.random() * 300 + 100 },
//       type: "customBubble",
//       data: {
//         templateName: name || "Untitled",
//         templateType: type || "text_template",
//         messageBody: body || "Message body preview...",
//         triggerButtonText: buttons[0]?.text || "",
//         triggerButtonType: "cta",
//         buttons: buttons.map((btn, idx) => ({
//           text: btn.text || "",
//           type: btn.type || "QUICK_REPLY",
//           subType: btn.subType || "",
//           value: btn.parameterValue || "",
//           targetNodeId: null,
//           index: idx,
//         })),
//       },
//     };
//     setNodes(nds => [...nds, newNode]);
//     setShowPicker(false);
//     toast.success(
//       `‚úÖ Step added with ${type?.replace("_", " ") || "template"}`
//     );
//     setTimeout(() => fitView({ padding: 0.2 }), 50);
//   };

//   // -------- Connection policy (pro-grade) --------
//   const isValidConnection = useCallback(
//     params => {
//       // Only one edge per (source, sourceHandle)
//       if (!params?.source || !params?.sourceHandle) return false;
//       const duplicate = edges.some(
//         e =>
//           e.source === params.source && e.sourceHandle === params.sourceHandle
//       );
//       return !duplicate;
//     },
//     [edges]
//   );

//   const onConnect = useCallback(
//     params => {
//       if (readonly) return;

//       // Label the edge with the handle (button text)
//       const label = params.sourceHandle || "";

//       // Visual edge
//       setEdges(eds =>
//         addEdge(
//           {
//             ...params,
//             id: uuidv4(),
//             type: "smoothstep",
//             animated: true,
//             style: { stroke: "#9333ea" },
//             markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
//             label,
//             labelStyle: { fontSize: 10, fill: "#4b5563" },
//             labelBgPadding: [4, 2],
//             labelBgBorderRadius: 4,
//             labelBgStyle: { fill: "#ffffff" },
//           },
//           eds
//         )
//       );

//       // Semantic link: tie edge to the specific button on source node
//       setNodes(nds =>
//         nds.map(node => {
//           if (node.id !== params.source) return node;

//           const sourceHandle = params.sourceHandle || "";
//           let updatedButtons = [...(node.data.buttons || [])];

//           // Find the button matching the handle (by text)
//           const idxByHandle = updatedButtons.findIndex(
//             b =>
//               (b.text || "").toLowerCase().trim() ===
//               sourceHandle.toLowerCase().trim()
//           );

//           if (idxByHandle >= 0) {
//             updatedButtons[idxByHandle] = {
//               ...updatedButtons[idxByHandle],
//               targetNodeId: params.target,
//             };
//           } else {
//             // Fallback: link the first unlinked button
//             const idxFirstUnlinked = updatedButtons.findIndex(
//               b => !b.targetNodeId
//             );
//             if (idxFirstUnlinked >= 0) {
//               updatedButtons[idxFirstUnlinked] = {
//                 ...updatedButtons[idxFirstUnlinked],
//                 targetNodeId: params.target,
//               };
//             }
//           }
//           return { ...node, data: { ...node.data, buttons: updatedButtons } };
//         })
//       );
//     },
//     [readonly, setEdges, setNodes]
//   );

//   // -------- Keyboard UX --------
//   useEffect(() => {
//     const onKey = e => {
//       if (readonly) return;
//       if (e.key === "Delete" || e.key === "Backspace") {
//         setNodes(nds => nds.filter(n => !n.selected));
//         setEdges(eds => eds.filter(ed => !ed.selected));
//       }
//       if (e.key === "Escape") {
//         setNodes(nds => nds.map(n => ({ ...n, selected: false })));
//         setEdges(eds => eds.map(ed => ({ ...ed, selected: false })));
//       }
//     };
//     window.addEventListener("keydown", onKey);
//     return () => window.removeEventListener("keydown", onKey);
//   }, [readonly, setNodes, setEdges]);

//   // -------- Auto-layout (dagre) --------
//   const applyLayout = useCallback(
//     (direction = "LR") => {
//       const g = new dagre.graphlib.Graph();
//       g.setGraph({
//         rankdir: direction, // LR (left->right) or TB (top->bottom)
//         nodesep: 50,
//         ranksep: 90,
//         marginx: 20,
//         marginy: 20,
//       });
//       g.setDefaultEdgeLabel(() => ({}));

//       // seed nodes with approx size
//       nodes.forEach(n => {
//         const width = n?.measured?.width || NODE_DEFAULT.width;
//         const height = n?.measured?.height || NODE_DEFAULT.height;
//         g.setNode(n.id, { width, height });
//       });
//       edges.forEach(e => g.setEdge(e.source, e.target));

//       dagre.layout(g);

//       const laidOut = nodes.map(n => {
//         const { x, y } = g.node(n.id);
//         const width = n?.measured?.width || NODE_DEFAULT.width;
//         const height = n?.measured?.height || NODE_DEFAULT.height;
//         return {
//           ...n,
//           position: { x: x - width / 2, y: y - height / 2 },
//         };
//       });

//       setNodes(laidOut);
//       setTimeout(() => fitView({ padding: 0.2 }), 50);
//     },
//     [nodes, edges, setNodes, fitView]
//   );

//   // -------- Save --------
//   const handleSave = async isPublished => {
//     try {
//       // Transform nodes with stable Index per button
//       const transformedNodes = nodes
//         .filter(n => n?.data?.templateName)
//         .map(node => ({
//           Id: node.id || uuidv4(),
//           TemplateName: node?.data?.templateName || "Untitled",
//           TemplateType: node?.data?.templateType || "text_template",
//           MessageBody: node?.data?.messageBody || "",
//           PositionX: node.position?.x || 0,
//           PositionY: node.position?.y || 0,
//           TriggerButtonText: node?.data?.triggerButtonText || "",
//           TriggerButtonType: node?.data?.triggerButtonType || "cta",
//           RequiredTag: node?.data?.requiredTag || "",
//           RequiredSource: node?.data?.requiredSource || "",
//           Buttons: (node?.data?.buttons || [])
//             .filter(btn => (btn.text || "").trim().length > 0)
//             .map((btn, idx) => ({
//               Text: (btn.text || "").trim(),
//               Type: btn.type || "QUICK_REPLY",
//               SubType: btn.subType || "",
//               Value: btn.value || "",
//               TargetNodeId: btn.targetNodeId || null,
//               Index: typeof btn.index === "number" ? btn.index : idx,
//             })),
//         }));

//       const transformedEdges = edges.map(edge => ({
//         FromNodeId: edge.source,
//         ToNodeId: edge.target,
//         SourceHandle: edge.sourceHandle || "", // should match Button Text
//       }));

//       const payload = {
//         FlowName: flowName || "Untitled",
//         IsPublished: isPublished ?? false,
//         Nodes: transformedNodes,
//         Edges: transformedEdges,
//       };

//       console.log("üì§ Final Payload to POST:", payload);
//       await saveVisualFlow(payload);
//       toast.success("‚úÖ Flow saved successfully");
//     } catch (error) {
//       console.error("‚ùå Save flow failed: ", error);
//       toast.error("‚ùå Failed to save flow");
//     }
//   };

//   // -------- Default edge appearance --------
//   const defaultEdgeOptions = useMemo(
//     () => ({
//       type: "smoothstep",
//       animated: true,
//       style: { stroke: "#9333ea" },
//       markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
//     }),
//     []
//   );

//   return (
//     <div className="p-6">
//       {/* Header */}
//       <div className="flex justify-between items-center mb-4">
//         <h2 className="text-2xl font-bold text-purple-700">
//           üß† CTA Flow Visual Builder
//         </h2>

//         {!readonly && (
//           <div className="flex items-center gap-2 flex-wrap">
//             <input
//               id="flowName"
//               name="flowName"
//               ref={flowNameRef}
//               value={flowName}
//               onChange={e => setFlowName(e.target.value)}
//               placeholder="Add flow name"
//               className="border border-gray-300 px-3 py-2 rounded-md shadow-sm text-sm"
//             />
//             <button
//               onClick={() => setShowPicker(true)}
//               className="bg-purple-600 text-white px-4 py-2 rounded shadow hover:bg-purple-700 text-sm"
//             >
//               ‚ûï Add Step
//             </button>
//             <button
//               onClick={() => navigate("/app/cta-flow/flow-manager")}
//               className="bg-white border border-purple-600 text-purple-700 font-medium text-sm px-4 py-2 rounded-md shadow-sm hover:bg-purple-50"
//             >
//               ‚Ü©Ô∏è Manage All Flows
//             </button>
//           </div>
//         )}
//       </div>

//       {/* Canvas */}
//       <div className="h-[70vh] border rounded-xl bg-gray-50 relative">
//         {/* Minimap toggle */}
//         <div className="absolute bottom-5 right-4 z-50 flex gap-2">
//           <button
//             onClick={() => setShowMiniMap(prev => !prev)}
//             className="bg-purple-600 text-white p-2 rounded-full shadow hover:bg-purple-700"
//             title={showMiniMap ? "Hide MiniMap" : "Show MiniMap"}
//           >
//             {showMiniMap ? <Minus size={15} /> : <Eye size={15} />}
//           </button>

//           {/* Fit / Zoom / Auto-layout */}
//           <div className="flex items-center gap-2 bg-white/90 px-2 py-1 rounded-full border">
//             <button
//               onClick={() => fitView({ padding: 0.2 })}
//               className="text-xs px-2 py-1 rounded hover:bg-gray-100"
//               title="Fit"
//             >
//               Fit
//             </button>
//             <button
//               onClick={() => zoomIn()}
//               className="text-xs px-2 py-1 rounded hover:bg-gray-100"
//               title="Zoom In"
//             >
//               +
//             </button>
//             <button
//               onClick={() => zoomOut()}
//               className="text-xs px-2 py-1 rounded hover:bg-gray-100"
//               title="Zoom Out"
//             >
//               ‚àí
//             </button>
//             {!readonly && (
//               <>
//                 <button
//                   onClick={() => applyLayout("LR")}
//                   className="text-xs px-2 py-1 rounded hover:bg-gray-100"
//                   title="Auto-layout (Left‚ÜíRight)"
//                 >
//                   Auto LR
//                 </button>
//                 <button
//                   onClick={() => applyLayout("TB")}
//                   className="text-xs px-2 py-1 rounded hover:bg-gray-100"
//                   title="Auto-layout (Top‚ÜíBottom)"
//                 >
//                   Auto TB
//                 </button>
//               </>
//             )}
//           </div>
//         </div>

//         <ReactFlow
//           nodes={nodes}
//           edges={edges}
//           onNodesChange={onNodesChange}
//           onEdgesChange={onEdgesChange}
//           onConnect={onConnect}
//           onEdgeClick={(e, edge) => {
//             if (!readonly) setEdges(eds => eds.filter(ed => ed.id !== edge.id));
//           }}
//           nodeTypes={nodeTypes}
//           fitView
//           fitViewOptions={{ padding: 0.2 }}
//           defaultEdgeOptions={defaultEdgeOptions}
//           // ‚ú® Pro feel
//           connectionMode={ConnectionMode.Strict}
//           isValidConnection={isValidConnection}
//           snapToGrid
//           snapGrid={[GRID, GRID]}
//           panOnScroll
//           zoomOnPinch
//           panOnDrag={[1, 2]} // allow panning from empty space & ctrl/shift drag
//           selectionOnDrag
//           nodesDraggable={!readonly}
//           nodesConnectable={!readonly}
//           elementsSelectable={!readonly}
//           // keep sourceHandle label visible in edge labels
//         >
//           {showMiniMap && (
//             <MiniMap
//               nodeColor="#9333ea"
//               nodeStrokeWidth={2}
//               maskColor="rgba(255,255,255,0.6)"
//             />
//           )}
//           <Controls />
//           <Background variant="dots" gap={GRID} size={1} />
//         </ReactFlow>
//       </div>

//       {/* Footer actions */}
//       {!readonly && (
//         <div className="mt-6 flex gap-4">
//           <button
//             onClick={() => handleSave(false)}
//             className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm"
//           >
//             üíæ Save Draft
//           </button>
//           <button
//             onClick={() => handleSave(true)}
//             className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-sm"
//           >
//             üöÄ Publish Flow
//           </button>
//         </div>
//       )}

//       <TemplatePickerModal
//         open={showPicker}
//         onClose={() => setShowPicker(false)}
//         onSelect={handleTemplateSelect}
//       />
//     </div>
//   );
// }

// export default function CTAFlowVisualBuilder() {
//   return (
//     <ReactFlowProvider>
//       <CTAFlowVisualBuilderInner />
//     </ReactFlowProvider>
//   );
// }

// import React, {
//   useCallback,
//   useState,
//   useEffect,
//   useMemo,
//   useRef,
// } from "react";
// import {
//   ReactFlow,
//   ReactFlowProvider,
//   Background,
//   Controls,
//   MiniMap,
//   useNodesState,
//   useEdgesState,
//   addEdge,
//   MarkerType,
// } from "@xyflow/react";
// import "@xyflow/react/dist/style.css";
// import { Eye, Minus } from "lucide-react";
// import { useSearchParams, useNavigate } from "react-router-dom";
// import TemplatePickerModal from "./components/TemplatePickerModal";
// import FlowNodeBubble from "./components/FlowNodeBubble";
// import { saveVisualFlow, getVisualFlowById } from "./ctaFlowVisualApi";
// import { v4 as uuidv4 } from "uuid";
// import { toast } from "react-toastify";

// function CTAFlowVisualBuilderInner() {
//   const [nodes, setNodes, onNodesChange] = useNodesState([]);
//   const [edges, setEdges, onEdgesChange] = useEdgesState([]);
//   const nodesRef = useRef([]);
//   const [showPicker, setShowPicker] = useState(false);
//   const [flowName, setFlowName] = useState("");
//   const flowNameRef = useRef(null);
//   const [showMiniMap, setShowMiniMap] = useState(false);
//   const [readonly, setReadonly] = useState(false);
//   const [searchParams] = useSearchParams();
//   const navigate = useNavigate();
//   const mode = searchParams.get("mode");
//   const flowId = searchParams.get("id");
//   const visualDebug = true;

//   useEffect(() => {
//     nodesRef.current = [...nodes];
//   }, [nodes]);

//   const handleDeleteNode = useCallback(
//     nodeId => {
//       if (readonly) return;
//       setNodes(nds => nds.filter(n => n.id !== nodeId));
//       setEdges(eds =>
//         eds.filter(e => e.source !== nodeId && e.target !== nodeId)
//       );
//     },
//     [readonly, setNodes, setEdges]
//   );

//   const handleNodeDataChange = useCallback(
//     (nodeId, newData) => {
//       setNodes(nds =>
//         nds.map(n =>
//           n.id === nodeId ? { ...n, data: { ...n.data, ...newData } } : n
//         )
//       );
//     },
//     [setNodes]
//   );

//   const nodeTypes = useMemo(
//     () => ({
//       customBubble: props => (
//         <FlowNodeBubble
//           {...props}
//           onDelete={handleDeleteNode}
//           onDataChange={newData => handleNodeDataChange(props.id, newData)}
//           readonly={readonly}
//           visualDebug={visualDebug}
//         />
//       ),
//     }),
//     [handleDeleteNode, readonly, visualDebug, handleNodeDataChange]
//   );

//   useEffect(() => {
//     const load = async () => {
//       if (mode === "edit" || mode === "view") {
//         try {
//           const data = await getVisualFlowById(flowId);

//           const builtNodes = data.nodes.map((node, index) => ({
//             id: node.id,
//             type: "customBubble",
//             position: {
//               x: node.positionX ?? 120 + index * 120,
//               y: node.positionY ?? 150 + (index % 5) * 60,
//             },
//             data: {
//               templateName: node.templateName,
//               templateType: node.templateType,
//               messageBody: node.messageBody,
//               triggerButtonText: node.triggerButtonText || "",
//               triggerButtonType: node.triggerButtonType || "cta",
//               requiredTag: node.requiredTag || "",
//               requiredSource: node.requiredSource || "",
//               // keep button order and include index if backend returned one
//               buttons: (node.buttons || []).map((btn, i) => ({
//                 text: btn.text,
//                 type: btn.type,
//                 subType: btn.subType,
//                 value: btn.value,
//                 targetNodeId: btn.targetNodeId || null,
//                 index: typeof btn.index === "number" ? btn.index : i, // <-- include index in UI state
//               })),
//             },
//           }));

//           const builtEdges = data.edges.map(edge => ({
//             id: `e-${edge.fromNodeId}-${edge.toNodeId}-${
//               edge.sourceHandle || "h"
//             }`,
//             source: edge.fromNodeId,
//             target: edge.toNodeId,
//             sourceHandle: edge.sourceHandle || null, // this should equal the button text
//             type: "smoothstep",
//             animated: true,
//             style: { stroke: "#9333ea" },
//             markerEnd: { type: "arrowclosed", color: "#9333ea" },
//           }));

//           // üîç Detect nodes with no incoming edges (often entry nodes; this is informational)
//           const nodesWithIncoming = new Set(builtEdges.map(e => e.target));
//           const nodesWithWarnings = builtNodes.map(node => ({
//             ...node,
//             data: {
//               ...node.data,
//               isUnreachable: false, // we won't block save on this for now
//               hasNoIncoming: !nodesWithIncoming.has(node.id),
//             },
//           }));

//           setNodes(nodesWithWarnings);
//           setEdges(builtEdges);
//           setFlowName(data.flowName);
//           if (mode === "view") setReadonly(true);
//         } catch {
//           toast.error("‚ùå Failed to load flow");
//         }
//       } else {
//         setNodes([]);
//         setEdges([]);
//         setFlowName("Untitled Flow");
//         setReadonly(false);
//       }
//     };

//     load();
//   }, [flowId, mode, setNodes, setEdges]);

//   const handleTemplateSelect = ({ name, type, body, buttons = [] }) => {
//     const id = uuidv4();
//     const newNode = {
//       id,
//       position: {
//         x: Math.random() * 400 + 100,
//         y: Math.random() * 300 + 100,
//       },
//       type: "customBubble",
//       data: {
//         templateName: name || "Untitled",
//         templateType: type || "text_template",
//         messageBody: body || "Message body preview...",
//         triggerButtonText: buttons[0]?.text || "",
//         triggerButtonType: "cta",
//         // ensure we keep button order & store index for each
//         buttons: buttons.map((btn, idx) => ({
//           text: btn.text || "",
//           type: btn.type || "QUICK_REPLY",
//           subType: btn.subType || "",
//           value: btn.parameterValue || "",
//           targetNodeId: null,
//           index: idx, // <-- tracked in UI so we can send Index later
//         })),
//       },
//     };
//     setNodes(nds => [...nds, newNode]);
//     setShowPicker(false);
//     toast.success(
//       `‚úÖ Step added with ${type?.replace("_", " ") || "template"}`
//     );
//   };

//   const onConnect = useCallback(
//     params => {
//       if (readonly) return;

//       // Add the visual edge
//       setEdges(eds =>
//         addEdge(
//           {
//             ...params,
//             id: uuidv4(),
//             type: "smoothstep",
//             animated: true,
//             style: { stroke: "#9333ea" },
//             markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
//           },
//           eds
//         )
//       );

//       // IMPORTANT: tie the edge to the specific button on the source node
//       setNodes(nds =>
//         nds.map(node => {
//           if (node.id !== params.source) return node;

//           const sourceHandle = params.sourceHandle || ""; // should equal button text
//           let updatedButtons = [...(node.data.buttons || [])];

//           // Try to find the button that matches the handle (by text)
//           const idxByHandle = updatedButtons.findIndex(
//             b =>
//               (b.text || "").toLowerCase().trim() ===
//               sourceHandle.toLowerCase().trim()
//           );

//           if (idxByHandle >= 0) {
//             updatedButtons[idxByHandle] = {
//               ...updatedButtons[idxByHandle],
//               targetNodeId: params.target,
//             };
//           } else {
//             // Fallback: link the first unlinked button
//             const idxFirstUnlinked = updatedButtons.findIndex(
//               b => !b.targetNodeId
//             );
//             if (idxFirstUnlinked >= 0) {
//               updatedButtons[idxFirstUnlinked] = {
//                 ...updatedButtons[idxFirstUnlinked],
//                 targetNodeId: params.target,
//               };
//             }
//           }

//           return { ...node, data: { ...node.data, buttons: updatedButtons } };
//         })
//       );
//     },
//     [readonly, setEdges, setNodes]
//   );

//   // --- Save ---

//   const handleSave = async isPublished => {
//     try {
//       // ‚úÖ Transform nodes with stable Index per button
//       const transformedNodes = nodes
//         .filter(n => n?.data?.templateName)
//         .map(node => ({
//           Id: node.id || uuidv4(),
//           TemplateName: node?.data?.templateName || "Untitled",
//           TemplateType: node?.data?.templateType || "text_template",
//           MessageBody: node?.data?.messageBody || "",
//           PositionX: node.position?.x || 0,
//           PositionY: node.position?.y || 0,
//           TriggerButtonText: node?.data?.triggerButtonText || "",
//           TriggerButtonType: node?.data?.triggerButtonType || "cta",
//           RequiredTag: node?.data?.requiredTag || "",
//           RequiredSource: node?.data?.requiredSource || "",
//           Buttons: (node?.data?.buttons || [])
//             .filter(btn => (btn.text || "").trim().length > 0)
//             .map((btn, idx) => ({
//               Text: (btn.text || "").trim(),
//               Type: btn.type || "QUICK_REPLY",
//               SubType: btn.subType || "",
//               Value: btn.value || "",
//               TargetNodeId: btn.targetNodeId || null,
//               Index: typeof btn.index === "number" ? btn.index : idx, // <-- send Index explicitly
//             })),
//         }));

//       const transformedEdges = edges.map(edge => ({
//         FromNodeId: edge.source,
//         ToNodeId: edge.target,
//         SourceHandle: edge.sourceHandle || "", // should match Button Text
//       }));

//       const payload = {
//         FlowName: flowName || "Untitled",
//         IsPublished: isPublished ?? false,
//         Nodes: transformedNodes,
//         Edges: transformedEdges,
//       };

//       console.log("üì§ Final Payload to POST:", payload);
//       await saveVisualFlow(payload);
//       toast.success("‚úÖ Flow saved successfully");
//     } catch (error) {
//       console.error("‚ùå Save flow failed: ", error);
//       toast.error("‚ùå Failed to save flow");
//     }
//   };

//   return (
//     <div className="p-6">
//       <div className="flex justify-between items-center mb-4">
//         <h2 className="text-2xl font-bold text-purple-700">
//           üß† CTA Flow Visual Builder
//         </h2>
//         {!readonly && (
//           <div className="flex items-center gap-4">
//             <input
//               id="flowName"
//               name="flowName"
//               ref={flowNameRef}
//               value={flowName}
//               onChange={e => setFlowName(e.target.value)}
//               placeholder="Add flow name"
//               className="border border-gray-300 px-3 py-2 rounded-md shadow-sm text-sm"
//             />
//             <button
//               onClick={() => setShowPicker(true)}
//               className="bg-purple-600 text-white px-4 py-2 rounded shadow hover:bg-purple-700 text-sm"
//             >
//               ‚ûï Add Step
//             </button>
//             <button
//               onClick={() => navigate("/app/cta-flow/flow-manager")}
//               className="bg-white border border-purple-600 text-purple-700 font-medium text-sm px-4 py-2 rounded-md shadow-sm hover:bg-purple-50"
//             >
//               ‚Ü©Ô∏è Manage All Flows
//             </button>
//           </div>
//         )}
//       </div>

//       <div className="h-[70vh] border rounded-xl bg-gray-50 relative">
//         <div className="absolute bottom-5 right-4 z-50">
//           <button
//             onClick={() => setShowMiniMap(prev => !prev)}
//             className="bg-purple-600 text-white p-2 rounded-full shadow hover:bg-purple-700"
//             title={showMiniMap ? "Hide MiniMap" : "Show MiniMap"}
//           >
//             {showMiniMap ? <Minus size={15} /> : <Eye size={15} />}
//           </button>
//         </div>

//         <ReactFlow
//           nodes={nodes}
//           edges={edges}
//           onNodesChange={onNodesChange}
//           onEdgesChange={onEdgesChange}
//           onConnect={onConnect}
//           onEdgeClick={(e, edge) => {
//             if (!readonly) setEdges(eds => eds.filter(ed => ed.id !== edge.id));
//           }}
//           nodeTypes={nodeTypes}
//           fitView
//         >
//           {showMiniMap && (
//             <MiniMap
//               nodeColor="#9333ea"
//               nodeStrokeWidth={2}
//               maskColor="rgba(255,255,255,0.6)"
//             />
//           )}
//           <Controls />
//           <Background />
//         </ReactFlow>
//       </div>

//       {!readonly && (
//         <div className="mt-6 flex gap-4">
//           <button
//             onClick={() => handleSave(false)}
//             className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm"
//           >
//             üíæ Save Draft
//           </button>
//           <button
//             onClick={() => handleSave(true)}
//             className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-sm"
//           >
//             üöÄ Publish Flow
//           </button>
//         </div>
//       )}

//       <TemplatePickerModal
//         open={showPicker}
//         onClose={() => setShowPicker(false)}
//         onSelect={handleTemplateSelect}
//       />
//     </div>
//   );
// }

// export default function CTAFlowVisualBuilder() {
//   return (
//     <ReactFlowProvider>
//       <CTAFlowVisualBuilderInner />
//     </ReactFlowProvider>
//   );
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\CTAFlowVisualBuilder_AllFileDump.txt 
====================================================== 
 
Folder and File Content Report
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\CTAFlowLogs.jsx 
====================================================== 
 
import React, { useEffect, useState } from "react";
import axiosClient from "../../api/axiosClient";
import { Card } from "../../components/ui/card";
import { Table, Thead, Tbody, Tr, Th, Td } from "../../components/ui/table";
import { format } from "date-fns";

const CTAFlowLogs = () => {
  const [logs, setLogs] = useState([]);

  useEffect(() => {
    axiosClient.get("/tracking/flow-clicks").then(res => {
      setLogs(res.data);
    });
  }, []);

  return (
    <div className="p-6">
      <h2 className="text-2xl font-bold mb-4">CTA Flow Click Logs</h2>
      <Card className="overflow-x-auto">
        <Table>
          <Thead>
            <Tr>
              <Th>Date</Th>
              <Th>Recipient</Th>
              <Th>Button</Th>
              <Th>Template</Th>
              <Th>Step ID</Th>
              <Th>Follow-Up</Th>
            </Tr>
          </Thead>
          <Tbody>
            {logs.map(log => (
              <Tr key={log.id}>
                <Td>
                  {format(new Date(log.clickedAt), "dd MMM yyyy hh:mm a")}
                </Td>
                <Td>{log.contactPhone}</Td>
                <Td>{log.buttonText}</Td>
                <Td>{log.templateId}</Td>
                <Td className="text-xs">{log.stepId}</Td>
                <Td>
                  {log.followUpSent ? (
                    <span className="text-green-600 font-semibold">‚úÖ Yes</span>
                  ) : (
                    <span className="text-gray-500">‚Äî</span>
                  )}
                </Td>
              </Tr>
            ))}
          </Tbody>
        </Table>
      </Card>
    </div>
  );
};

export default CTAFlowLogs;
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\CTAFlowManager.jsx 
====================================================== 
 
import React, { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import axiosClient from "../../api/axiosClient";
import { toast } from "react-toastify";

export default function CTAFlowManager() {
  const [flows, setFlows] = useState([]);
  const [activeTab, setActiveTab] = useState("draft");
  const navigate = useNavigate();

  const fetchFlows = async (tab = "draft") => {
    try {
      const endpoint =
        tab === "published" ? "/cta-flow/all-published" : "/cta-flow/all-draft";

      const res = await axiosClient.get(endpoint);
      setFlows(Array.isArray(res.data) ? res.data : [res.data]);
    } catch (err) {
      toast.error("‚ùå Failed to load flows");
      console.error(err);
    }
  };

  useEffect(() => {
    fetchFlows("draft");
  }, []);

  const handleDelete = async id => {
    const confirm = window.confirm(
      "Are you sure you want to delete this flow?"
    );
    if (!confirm) return;

    try {
      await axiosClient.delete(`/cta-flow/delete/${id}`);
      toast.success("‚úÖ Flow deleted successfully");
      fetchFlows(activeTab);
    } catch (err) {
      toast.error("‚ùå Failed to delete flow");
      console.error(err);
    }
  };

  const formatDate = date => {
    const d = new Date(date);
    return d.toLocaleDateString("en-IN", {
      day: "2-digit",
      month: "short",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  return (
    <div className="p-6">
      {/* Header */}
      <div className="flex justify-between items-center mb-6">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">
            üß© CTA Flow Manager
          </h1>
          <p className="text-sm text-gray-500">
            Create, edit, and manage your visual flows.
          </p>
        </div>
        <button
          onClick={() => navigate("/app/cta-flow/visual-builder")}
          className="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-md shadow"
        >
          ‚ûï New Flow
        </button>
      </div>

      {/* Tabs */}
      <div className="flex gap-6 border-b mb-4 text-sm font-medium">
        {["draft", "published"].map(tab => (
          <button
            key={tab}
            className={`pb-2 transition-all ${
              activeTab === tab
                ? "text-purple-600 border-b-2 border-purple-600"
                : "text-gray-500 hover:text-purple-600"
            }`}
            onClick={() => {
              setActiveTab(tab);
              fetchFlows(tab);
            }}
          >
            {tab === "draft" ? "üìù Draft Flows" : "‚úÖ Published Flows"}
          </button>
        ))}
      </div>

      {/* Table */}
      {flows.length === 0 ? (
        <div className="text-gray-500 text-center py-10">
          No {activeTab} flows found.
        </div>
      ) : (
        <div className="bg-white rounded-xl shadow overflow-hidden">
          <table className="w-full text-sm text-left">
            <thead className="bg-gray-50 border-b text-gray-500 uppercase text-xs tracking-wide">
              <tr>
                <th className="px-4 py-3">Flow Name</th>
                <th className="px-4 py-3">Status</th>
                <th className="px-4 py-3">Last Modified</th>
                <th className="px-4 py-3 text-right">Actions</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-100">
              {flows.map(flow => (
                <tr
                  key={flow.id}
                  className="hover:bg-gray-50 transition-all duration-150"
                >
                  <td className="px-4 py-3 font-medium text-gray-800">
                    {flow.flowName}
                  </td>
                  <td className="px-4 py-3">
                    {flow.isPublished ? (
                      <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-700">
                        ‚úÖ Published
                      </span>
                    ) : (
                      <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-700">
                        üìù Draft
                      </span>
                    )}
                  </td>
                  <td className="px-4 py-3 text-gray-600">
                    {formatDate(flow.updatedAt || flow.createdAt)}
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex justify-end gap-2">
                      <button
                        onClick={() =>
                          navigate(
                            `/app/cta-flow-builder?id=${flow.id}&mode=view`
                          )
                        }
                        className="text-blue-600 hover:underline text-xs"
                      >
                        üëÅÔ∏è View
                      </button>
                      {!flow.isPublished && (
                        <button
                          onClick={() =>
                            navigate(
                              `/app/cta-flow-builder?id=${flow.id}&mode=edit`
                            )
                          }
                          className="text-yellow-600 hover:underline text-xs"
                        >
                          ‚úèÔ∏è Edit
                        </button>
                      )}
                      <button
                        onClick={() => handleDelete(flow.id)}
                        className="text-red-600 hover:underline text-xs"
                      >
                        üóëÔ∏è Delete
                      </button>
                    </div>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\ctaFlowVisualApi.js 
====================================================== 
 
import axiosClient from "../../api/axiosClient";

// ‚úÖ FINAL version with Index support for buttons
export async function saveVisualFlow(payload) {
  const safeNodes = (payload.Nodes || []).map(node => {
    return {
      Id: node.Id || "",
      TemplateName: node.TemplateName || "",
      TemplateType: node.TemplateType || "text_template",
      MessageBody: node.MessageBody || "",
      PositionX: node.PositionX ?? 0,
      PositionY: node.PositionY ?? 0,
      TriggerButtonText: node.TriggerButtonText || "",
      TriggerButtonType: node.TriggerButtonType || "cta",
      Buttons: (node.Buttons || []).map((btn, idx) => ({
        Text: btn.Text || "",
        Type: btn.Type || "",
        SubType: btn.SubType || "",
        Value: btn.Value || "",
        TargetNodeId: btn.TargetNodeId || null,
        Index: typeof btn.Index === "number" ? btn.Index : idx, // ‚úÖ preserve Index
      })),
    };
  });

  const safeEdges = (payload.Edges || []).map(edge => ({
    FromNodeId: edge.FromNodeId || "",
    ToNodeId: edge.ToNodeId || "",
    SourceHandle: edge.SourceHandle || "",
  }));

  const fixedPayload = {
    FlowName: payload.FlowName || "Untitled",
    IsPublished: payload.IsPublished ?? false,
    Nodes: safeNodes,
    Edges: safeEdges,
  };

  console.log("üì§ Sending flow to API:", fixedPayload);
  const response = await axiosClient.post(
    "/cta-flow/save-visual",
    fixedPayload
  );
  return response.data;
}

// üì• Load a specific visual flow by ID
export async function getVisualFlowById(flowId) {
  const res = await axiosClient.get(`/cta-flow/by-id/${flowId}`);
  return res.data;
}

// import axiosClient from "../../api/axiosClient";
// // Removed: import { v4 as uuidv4 } from "uuid"; // Not used

// // ‚úÖ FINAL version with UUID fallback for node.Id
// // ‚úÖ Accept the full payload object
// export async function saveVisualFlow(payload) {
//   const safeNodes = (payload.Nodes || []).map(node => {
//     // Removed: const data = node.data || {}; // Not used
//     return {
//       Id: node.Id || "",
//       TemplateName: node.TemplateName || "",
//       TemplateType: node.TemplateType || "text_template",
//       MessageBody: node.MessageBody || "",
//       PositionX: node.PositionX ?? 0,
//       PositionY: node.PositionY ?? 0,
//       TriggerButtonText: node.TriggerButtonText || "",
//       TriggerButtonType: node.TriggerButtonType || "cta",
//       Buttons: (node.Buttons || []).map(btn => ({
//         Text: btn.Text || "",
//         Type: btn.Type || "",
//         SubType: btn.SubType || "",
//         Value: btn.Value || "",
//         TargetNodeId: btn.TargetNodeId || null,
//       })),
//     };
//   });

//   const safeEdges = (payload.Edges || []).map(edge => ({
//     FromNodeId: edge.FromNodeId || "",
//     ToNodeId: edge.ToNodeId || "",
//     SourceHandle: edge.SourceHandle || "",
//   }));

//   const fixedPayload = {
//     FlowName: payload.FlowName || "Untitled",
//     IsPublished: payload.IsPublished ?? false,
//     Nodes: safeNodes,
//     Edges: safeEdges,
//   };

//   console.log("üì§ Sending minimal flow to API:", fixedPayload);
//   const response = await axiosClient.post(
//     "/cta-flow/save-visual",
//     fixedPayload
//   );
//   return response.data;
// }

// // üì• Load a specific visual flow by ID
// export async function getVisualFlowById(flowId) {
//   const res = await axiosClient.get(`/cta-flow/by-id/${flowId}`);
//   return res.data;
// }

// import axiosClient from "../../api/axiosClient";
// import { v4 as uuidv4 } from "uuid"; // ‚úÖ Ensure UUID generator is imported

// // ‚úÖ FINAL version with UUID fallback for node.Id
// // ‚úÖ Accept the full payload object
// export async function saveVisualFlow(payload) {
//   const safeNodes = (payload.Nodes || []).map(node => {
//     const data = node.data || {};
//     return {
//       Id: node.Id || "",
//       TemplateName: node.TemplateName || "",
//       TemplateType: node.TemplateType || "text_template",
//       MessageBody: node.MessageBody || "",
//       PositionX: node.PositionX ?? 0,
//       PositionY: node.PositionY ?? 0,
//       TriggerButtonText: node.TriggerButtonText || "",
//       TriggerButtonType: node.TriggerButtonType || "cta",
//       Buttons: (node.Buttons || []).map(btn => ({
//         Text: btn.Text || "",
//         Type: btn.Type || "",
//         SubType: btn.SubType || "",
//         Value: btn.Value || "",
//         TargetNodeId: btn.TargetNodeId || null,
//       })),
//     };
//   });

//   const safeEdges = (payload.Edges || []).map(edge => ({
//     FromNodeId: edge.FromNodeId || "",
//     ToNodeId: edge.ToNodeId || "",
//     SourceHandle: edge.SourceHandle || "",
//   }));

//   const fixedPayload = {
//     FlowName: payload.FlowName || "Untitled",
//     IsPublished: payload.IsPublished ?? false,
//     Nodes: safeNodes,
//     Edges: safeEdges,
//   };

//   console.log("üì§ Sending minimal flow to API:", fixedPayload);
//   const response = await axiosClient.post(
//     "/cta-flow/save-visual",
//     fixedPayload
//   );
//   return response.data;
// }

// // üì• Load a specific visual flow by ID
// export async function getVisualFlowById(flowId) {
//   const res = await axiosClient.get(`/cta-flow/by-id/${flowId}`);
//   return res.data;
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\CTAFlowVisualBuilder.jsx 
====================================================== 
 
import React, {
  useCallback,
  useState,
  useEffect,
  useMemo,
  useRef,
} from "react";
import {
  ReactFlow,
  ReactFlowProvider,
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  addEdge,
  MarkerType,
  ConnectionMode,
  useReactFlow,
} from "@xyflow/react";
import "@xyflow/react/dist/style.css";
import { Eye, Minus } from "lucide-react";
import { useSearchParams, useNavigate } from "react-router-dom";
import TemplatePickerModal from "./components/TemplatePickerModal";
import FlowNodeBubble from "./components/FlowNodeBubble";
import { saveVisualFlow, getVisualFlowById } from "./ctaFlowVisualApi";
import { v4 as uuidv4 } from "uuid";
import { toast } from "react-toastify";
import dagre from "dagre";

// NEW: custom edge that flips label vertically when space is tight
import SmartLabeledEdge from "./components/edges/SmartLabeledEdge";

const GRID = 16;
const NODE_DEFAULT = { width: 260, height: 140 }; // safe defaults for dagre when sizes are unknown

function CTAFlowVisualBuilderInner() {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const nodesRef = useRef([]);
  const [showPicker, setShowPicker] = useState(false);
  const [flowName, setFlowName] = useState("");
  const flowNameRef = useRef(null);
  const [showMiniMap, setShowMiniMap] = useState(false);
  const [readonly, setReadonly] = useState(false);
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const { fitView, zoomIn, zoomOut } = useReactFlow();
  const mode = searchParams.get("mode");
  const flowId = searchParams.get("id");
  const visualDebug = true;

  useEffect(() => {
    nodesRef.current = [...nodes];
  }, [nodes]);

  // -------- Node helpers --------
  const handleDeleteNode = useCallback(
    nodeId => {
      if (readonly) return;
      setNodes(nds => nds.filter(n => n.id !== nodeId));
      setEdges(eds =>
        eds.filter(e => e.source !== nodeId && e.target !== nodeId)
      );
    },
    [readonly, setNodes, setEdges]
  );

  const handleNodeDataChange = useCallback(
    (nodeId, newData) => {
      setNodes(nds =>
        nds.map(n =>
          n.id === nodeId ? { ...n, data: { ...n.data, ...newData } } : n
        )
      );
    },
    [setNodes]
  );

  const nodeTypes = useMemo(
    () => ({
      customBubble: props => (
        <FlowNodeBubble
          {...props}
          onDelete={handleDeleteNode}
          onDataChange={newData => handleNodeDataChange(props.id, newData)}
          readonly={readonly}
          visualDebug={visualDebug}
        />
      ),
    }),
    [handleDeleteNode, readonly, visualDebug, handleNodeDataChange]
  );

  // NEW: register custom edge
  const edgeTypes = useMemo(() => ({ smart: SmartLabeledEdge }), []);

  // -------- Load / Bootstrap --------
  useEffect(() => {
    const load = async () => {
      if (mode === "edit" || mode === "view") {
        try {
          const data = await getVisualFlowById(flowId);

          const builtNodes = (data.nodes || []).map((node, index) => ({
            id: node.id,
            type: "customBubble",
            position: {
              x: node.positionX ?? 120 + index * 120,
              y: node.positionY ?? 150 + (index % 5) * 60,
            },
            data: {
              templateName: node.templateName,
              templateType: node.templateType,
              messageBody: node.messageBody,
              triggerButtonText: node.triggerButtonText || "",
              triggerButtonType: node.triggerButtonType || "cta",
              requiredTag: node.requiredTag || "",
              requiredSource: node.requiredSource || "",
              buttons: (node.buttons || []).map((btn, i) => ({
                text: btn.text,
                type: btn.type,
                subType: btn.subType,
                value: btn.value,
                targetNodeId: btn.targetNodeId || null,
                index: typeof btn.index === "number" ? btn.index : i,
              })),
            },
          }));

          const builtEdges = (data.edges || []).map(edge => ({
            id: `e-${edge.fromNodeId}-${edge.toNodeId}-${
              edge.sourceHandle || "h"
            }`,
            source: edge.fromNodeId,
            target: edge.toNodeId,
            sourceHandle: edge.sourceHandle || null, // equals button text
            type: "smart", // <-- use custom edge
            animated: true,
            style: { stroke: "#9333ea" },
            markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
            label: edge.sourceHandle || "", // show button text on edge
          }));

          const nodesWithIncoming = new Set(builtEdges.map(e => e.target));
          const nodesWithWarnings = builtNodes.map(node => ({
            ...node,
            data: {
              ...node.data,
              isUnreachable: false,
              hasNoIncoming: !nodesWithIncoming.has(node.id),
            },
          }));

          setNodes(nodesWithWarnings);
          setEdges(builtEdges);
          setFlowName(data.flowName || "Untitled Flow");
          if (mode === "view") setReadonly(true);

          setTimeout(() => fitView({ padding: 0.2 }), 50);
        } catch {
          toast.error("‚ùå Failed to load flow");
        }
      } else {
        setNodes([]);
        setEdges([]);
        setFlowName("Untitled Flow");
        setReadonly(false);
        setTimeout(() => fitView({ padding: 0.2 }), 50);
      }
    };

    load();
  }, [flowId, mode, setNodes, setEdges, fitView]);

  // -------- Template add --------
  const handleTemplateSelect = ({ name, type, body, buttons = [] }) => {
    const id = uuidv4();
    const newNode = {
      id,
      position: { x: Math.random() * 400 + 100, y: Math.random() * 300 + 100 },
      type: "customBubble",
      data: {
        templateName: name || "Untitled",
        templateType: type || "text_template",
        messageBody: body || "Message body preview...",
        triggerButtonText: buttons[0]?.text || "",
        triggerButtonType: "cta",
        buttons: buttons.map((btn, idx) => ({
          text: btn.text || "",
          type: btn.type || "QUICK_REPLY",
          subType: btn.subType || "",
          value: btn.parameterValue || "",
          targetNodeId: null,
          index: idx,
        })),
      },
    };
    setNodes(nds => [...nds, newNode]);
    setShowPicker(false);
    toast.success(
      `‚úÖ Step added with ${type?.replace("_", " ") || "template"}`
    );
    setTimeout(() => fitView({ padding: 0.2 }), 50);
  };

  // -------- Connection policy (pro-grade) --------
  const isValidConnection = useCallback(
    params => {
      if (!params?.source || !params?.sourceHandle) return false; // require handle‚Üíhandle
      // Only one edge per (source, sourceHandle)
      const duplicate = edges.some(
        e =>
          e.source === params.source && e.sourceHandle === params.sourceHandle
      );
      return !duplicate;
    },
    [edges]
  );

  const onConnect = useCallback(
    params => {
      if (readonly) return;

      const label = params.sourceHandle || "";

      // Visual edge (custom)
      setEdges(eds =>
        addEdge(
          {
            ...params,
            id: uuidv4(),
            type: "smart",
            animated: true,
            style: { stroke: "#9333ea" },
            markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
            label,
          },
          eds
        )
      );

      // Semantic link: tie edge to the specific button on source node
      setNodes(nds =>
        nds.map(node => {
          if (node.id !== params.source) return node;

          const sourceHandle = params.sourceHandle || "";
          let updatedButtons = [...(node.data.buttons || [])];

          const idxByHandle = updatedButtons.findIndex(
            b =>
              (b.text || "").toLowerCase().trim() ===
              sourceHandle.toLowerCase().trim()
          );

          if (idxByHandle >= 0) {
            updatedButtons[idxByHandle] = {
              ...updatedButtons[idxByHandle],
              targetNodeId: params.target,
            };
          } else {
            const idxFirstUnlinked = updatedButtons.findIndex(
              b => !b.targetNodeId
            );
            if (idxFirstUnlinked >= 0) {
              updatedButtons[idxFirstUnlinked] = {
                ...updatedButtons[idxFirstUnlinked],
                targetNodeId: params.target,
              };
            }
          }
          return { ...node, data: { ...node.data, buttons: updatedButtons } };
        })
      );
    },
    [readonly, setEdges, setNodes]
  );

  // -------- Keyboard UX --------
  useEffect(() => {
    const onKey = e => {
      if (readonly) return;
      if (e.key === "Delete" || e.key === "Backspace") {
        setNodes(nds => nds.filter(n => !n.selected));
        setEdges(eds => eds.filter(ed => !ed.selected));
      }
      if (e.key === "Escape") {
        setNodes(nds => nds.map(n => ({ ...n, selected: false })));
        setEdges(eds => eds.map(ed => ({ ...ed, selected: false })));
      }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [readonly, setNodes, setEdges]);

  // -------- Auto-layout (dagre) --------
  const applyLayout = useCallback(
    (direction = "LR") => {
      const g = new dagre.graphlib.Graph();
      g.setGraph({
        rankdir: direction, // LR (left->right) or TB (top->bottom)
        nodesep: 50,
        ranksep: 90,
        marginx: 20,
        marginy: 20,
      });
      g.setDefaultEdgeLabel(() => ({}));

      nodes.forEach(n => {
        const width = n?.measured?.width || NODE_DEFAULT.width;
        const height = n?.measured?.height || NODE_DEFAULT.height;
        g.setNode(n.id, { width, height });
      });
      edges.forEach(e => g.setEdge(e.source, e.target));

      dagre.layout(g);

      const laidOut = nodes.map(n => {
        const { x, y } = g.node(n.id);
        const width = n?.measured?.width || NODE_DEFAULT.width;
        const height = n?.measured?.height || NODE_DEFAULT.height;
        return {
          ...n,
          position: { x: x - width / 2, y: y - height / 2 },
        };
      });

      setNodes(laidOut);
      setTimeout(() => fitView({ padding: 0.2 }), 50);
    },
    [nodes, edges, setNodes, fitView]
  );

  // -------- Save --------
  const handleSave = async isPublished => {
    try {
      const transformedNodes = nodes
        .filter(n => n?.data?.templateName)
        .map(node => ({
          Id: node.id || uuidv4(),
          TemplateName: node?.data?.templateName || "Untitled",
          TemplateType: node?.data?.templateType || "text_template",
          MessageBody: node?.data?.messageBody || "",
          PositionX: node.position?.x || 0,
          PositionY: node.position?.y || 0,
          TriggerButtonText: node?.data?.triggerButtonText || "",
          TriggerButtonType: node?.data?.triggerButtonType || "cta",
          RequiredTag: node?.data?.requiredTag || "",
          RequiredSource: node?.data?.requiredSource || "",
          Buttons: (node?.data?.buttons || [])
            .filter(btn => (btn.text || "").trim().length > 0)
            .map((btn, idx) => ({
              Text: (btn.text || "").trim(),
              Type: btn.type || "QUICK_REPLY",
              SubType: btn.subType || "",
              Value: btn.value || "",
              TargetNodeId: btn.targetNodeId || null,
              Index: typeof btn.index === "number" ? btn.index : idx,
            })),
        }));

      const transformedEdges = edges.map(edge => ({
        FromNodeId: edge.source,
        ToNodeId: edge.target,
        SourceHandle: edge.sourceHandle || "",
      }));

      const payload = {
        FlowName: flowName || "Untitled",
        IsPublished: isPublished ?? false,
        Nodes: transformedNodes,
        Edges: transformedEdges,
      };

      console.log("üì§ Final Payload to POST:", payload);
      await saveVisualFlow(payload);
      toast.success("‚úÖ Flow saved successfully");
    } catch (error) {
      console.error("‚ùå Save flow failed: ", error);
      toast.error("‚ùå Failed to save flow");
    }
  };

  // -------- Default edge appearance --------
  const defaultEdgeOptions = useMemo(
    () => ({
      type: "smart", // <-- use custom smart edge by default
      animated: true,
      style: { stroke: "#9333ea" },
      markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
    }),
    []
  );

  return (
    <div className="p-6">
      {/* Header */}
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl font-bold text-purple-700">
          üß† CTA Flow Visual Builder
        </h2>

        {!readonly && (
          <div className="flex items-center gap-2 flex-wrap">
            <input
              id="flowName"
              name="flowName"
              ref={flowNameRef}
              value={flowName}
              onChange={e => setFlowName(e.target.value)}
              placeholder="Add flow name"
              className="border border-gray-300 px-3 py-2 rounded-md shadow-sm text-sm"
            />
            <button
              onClick={() => setShowPicker(true)}
              className="bg-purple-600 text-white px-4 py-2 rounded shadow hover:bg-purple-700 text-sm"
            >
              ‚ûï Add Step
            </button>
            <button
              onClick={() => navigate("/app/cta-flow/flow-manager")}
              className="bg-white border border-purple-600 text-purple-700 font-medium text-sm px-4 py-2 rounded-md shadow-sm hover:bg-purple-50"
            >
              ‚Ü©Ô∏è Manage All Flows
            </button>
          </div>
        )}
      </div>

      {/* Canvas */}
      <div className="h-[70vh] border rounded-xl bg-gray-50 relative">
        {/* Minimap + tools */}
        <div className="absolute bottom-5 right-4 z-50 flex gap-2">
          <button
            onClick={() => setShowMiniMap(prev => !prev)}
            className="bg-purple-600 text-white p-2 rounded-full shadow hover:bg-purple-700"
            title={showMiniMap ? "Hide MiniMap" : "Show MiniMap"}
          >
            {showMiniMap ? <Minus size={15} /> : <Eye size={15} />}
          </button>

          <div className="flex items-center gap-2 bg-white/90 px-2 py-1 rounded-full border">
            <button
              onClick={() => fitView({ padding: 0.2 })}
              className="text-xs px-2 py-1 rounded hover:bg-gray-100"
              title="Fit"
            >
              Fit
            </button>
            <button
              onClick={() => zoomIn()}
              className="text-xs px-2 py-1 rounded hover:bg-gray-100"
              title="Zoom In"
            >
              +
            </button>
            <button
              onClick={() => zoomOut()}
              className="text-xs px-2 py-1 rounded hover:bg-gray-100"
              title="Zoom Out"
            >
              ‚àí
            </button>
            {!readonly && (
              <>
                <button
                  onClick={() => applyLayout("LR")}
                  className="text-xs px-2 py-1 rounded hover:bg-gray-100"
                  title="Auto-layout (Left‚ÜíRight)"
                >
                  Auto LR
                </button>
                <button
                  onClick={() => applyLayout("TB")}
                  className="text-xs px-2 py-1 rounded hover:bg-gray-100"
                  title="Auto-layout (Top‚ÜíBottom)"
                >
                  Auto TB
                </button>
              </>
            )}
          </div>
        </div>

        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          onEdgeClick={(e, edge) => {
            if (!readonly) setEdges(eds => eds.filter(ed => ed.id !== edge.id));
          }}
          nodeTypes={nodeTypes}
          edgeTypes={edgeTypes} // <-- register custom edge
          fitView
          fitViewOptions={{ padding: 0.2 }}
          defaultEdgeOptions={defaultEdgeOptions}
          connectionMode={ConnectionMode.Strict}
          isValidConnection={isValidConnection}
          snapToGrid
          snapGrid={[GRID, GRID]}
          panOnScroll
          zoomOnPinch
          panOnDrag={[1, 2]}
          selectionOnDrag
          nodesDraggable={!readonly}
          nodesConnectable={!readonly}
          elementsSelectable={!readonly}
        >
          {showMiniMap && (
            <MiniMap
              nodeColor="#9333ea"
              nodeStrokeWidth={2}
              maskColor="rgba(255,255,255,0.6)"
            />
          )}
          <Controls />
          <Background variant="dots" gap={GRID} size={1} />
        </ReactFlow>
      </div>

      {/* Footer actions */}
      {!readonly && (
        <div className="mt-6 flex gap-4">
          <button
            onClick={() => handleSave(false)}
            className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm"
          >
            üíæ Save Draft
          </button>
          <button
            onClick={() => handleSave(true)}
            className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-sm"
          >
            üöÄ Publish Flow
          </button>
        </div>
      )}

      <TemplatePickerModal
        open={showPicker}
        onClose={() => setShowPicker(false)}
        onSelect={handleTemplateSelect}
      />
    </div>
  );
}

export default function CTAFlowVisualBuilder() {
  return (
    <ReactFlowProvider>
      <CTAFlowVisualBuilderInner />
    </ReactFlowProvider>
  );
}

// import React, {
//   useCallback,
//   useState,
//   useEffect,
//   useMemo,
//   useRef,
// } from "react";
// import {
//   ReactFlow,
//   ReactFlowProvider,
//   Background,
//   Controls,
//   MiniMap,
//   useNodesState,
//   useEdgesState,
//   addEdge,
//   MarkerType,
//   ConnectionMode,
//   useReactFlow,
// } from "@xyflow/react";
// import "@xyflow/react/dist/style.css";
// import { Eye, Minus } from "lucide-react";
// import { useSearchParams, useNavigate } from "react-router-dom";
// import TemplatePickerModal from "./components/TemplatePickerModal";
// import FlowNodeBubble from "./components/FlowNodeBubble";
// import { saveVisualFlow, getVisualFlowById } from "./ctaFlowVisualApi";
// import { v4 as uuidv4 } from "uuid";
// import { toast } from "react-toastify";
// import dagre from "dagre";

// const GRID = 16;
// const NODE_DEFAULT = { width: 260, height: 140 }; // safe defaults for dagre when sizes are unknown

// function CTAFlowVisualBuilderInner() {
//   const [nodes, setNodes, onNodesChange] = useNodesState([]);
//   const [edges, setEdges, onEdgesChange] = useEdgesState([]);
//   const nodesRef = useRef([]);
//   const [showPicker, setShowPicker] = useState(false);
//   const [flowName, setFlowName] = useState("");
//   const flowNameRef = useRef(null);
//   const [showMiniMap, setShowMiniMap] = useState(false);
//   const [readonly, setReadonly] = useState(false);
//   const [searchParams] = useSearchParams();
//   const navigate = useNavigate();
//   const { fitView, zoomIn, zoomOut } = useReactFlow();
//   const mode = searchParams.get("mode");
//   const flowId = searchParams.get("id");
//   const visualDebug = true;

//   useEffect(() => {
//     nodesRef.current = [...nodes];
//   }, [nodes]);

//   // -------- Node helpers --------
//   const handleDeleteNode = useCallback(
//     nodeId => {
//       if (readonly) return;
//       setNodes(nds => nds.filter(n => n.id !== nodeId));
//       setEdges(eds =>
//         eds.filter(e => e.source !== nodeId && e.target !== nodeId)
//       );
//     },
//     [readonly, setNodes, setEdges]
//   );

//   const handleNodeDataChange = useCallback(
//     (nodeId, newData) => {
//       setNodes(nds =>
//         nds.map(n =>
//           n.id === nodeId ? { ...n, data: { ...n.data, ...newData } } : n
//         )
//       );
//     },
//     [setNodes]
//   );

//   const nodeTypes = useMemo(
//     () => ({
//       customBubble: props => (
//         <FlowNodeBubble
//           {...props}
//           onDelete={handleDeleteNode}
//           onDataChange={newData => handleNodeDataChange(props.id, newData)}
//           readonly={readonly}
//           visualDebug={visualDebug}
//         />
//       ),
//     }),
//     [handleDeleteNode, readonly, visualDebug, handleNodeDataChange]
//   );

//   // -------- Load / Bootstrap --------
//   useEffect(() => {
//     const load = async () => {
//       if (mode === "edit" || mode === "view") {
//         try {
//           const data = await getVisualFlowById(flowId);

//           const builtNodes = (data.nodes || []).map((node, index) => ({
//             id: node.id,
//             type: "customBubble",
//             position: {
//               x: node.positionX ?? 120 + index * 120,
//               y: node.positionY ?? 150 + (index % 5) * 60,
//             },
//             data: {
//               templateName: node.templateName,
//               templateType: node.templateType,
//               messageBody: node.messageBody,
//               triggerButtonText: node.triggerButtonText || "",
//               triggerButtonType: node.triggerButtonType || "cta",
//               requiredTag: node.requiredTag || "",
//               requiredSource: node.requiredSource || "",
//               // keep button order and include index if backend returned one
//               buttons: (node.buttons || []).map((btn, i) => ({
//                 text: btn.text,
//                 type: btn.type,
//                 subType: btn.subType,
//                 value: btn.value,
//                 targetNodeId: btn.targetNodeId || null,
//                 index: typeof btn.index === "number" ? btn.index : i,
//               })),
//             },
//           }));

//           const builtEdges = (data.edges || []).map(edge => ({
//             id: `e-${edge.fromNodeId}-${edge.toNodeId}-${
//               edge.sourceHandle || "h"
//             }`,
//             source: edge.fromNodeId,
//             target: edge.toNodeId,
//             sourceHandle: edge.sourceHandle || null, // equals button text
//             type: "smoothstep",
//             animated: true,
//             style: { stroke: "#9333ea" },
//             markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
//             label: edge.sourceHandle || "", // <‚Äî show button text on edge
//             labelStyle: { fontSize: 10, fill: "#4b5563" },
//             labelBgPadding: [4, 2],
//             labelBgBorderRadius: 4,
//             labelBgStyle: { fill: "#ffffff" },
//           }));

//           // Informational flag
//           const nodesWithIncoming = new Set(builtEdges.map(e => e.target));
//           const nodesWithWarnings = builtNodes.map(node => ({
//             ...node,
//             data: {
//               ...node.data,
//               isUnreachable: false,
//               hasNoIncoming: !nodesWithIncoming.has(node.id),
//             },
//           }));

//           setNodes(nodesWithWarnings);
//           setEdges(builtEdges);
//           setFlowName(data.flowName || "Untitled Flow");
//           if (mode === "view") setReadonly(true);

//           // Fit after initial load
//           setTimeout(() => fitView({ padding: 0.2 }), 50);
//         } catch {
//           toast.error("‚ùå Failed to load flow");
//         }
//       } else {
//         setNodes([]);
//         setEdges([]);
//         setFlowName("Untitled Flow");
//         setReadonly(false);
//         setTimeout(() => fitView({ padding: 0.2 }), 50);
//       }
//     };

//     load();
//   }, [flowId, mode, setNodes, setEdges, fitView]);

//   // -------- Template add --------
//   const handleTemplateSelect = ({ name, type, body, buttons = [] }) => {
//     const id = uuidv4();
//     const newNode = {
//       id,
//       position: { x: Math.random() * 400 + 100, y: Math.random() * 300 + 100 },
//       type: "customBubble",
//       data: {
//         templateName: name || "Untitled",
//         templateType: type || "text_template",
//         messageBody: body || "Message body preview...",
//         triggerButtonText: buttons[0]?.text || "",
//         triggerButtonType: "cta",
//         buttons: buttons.map((btn, idx) => ({
//           text: btn.text || "",
//           type: btn.type || "QUICK_REPLY",
//           subType: btn.subType || "",
//           value: btn.parameterValue || "",
//           targetNodeId: null,
//           index: idx,
//         })),
//       },
//     };
//     setNodes(nds => [...nds, newNode]);
//     setShowPicker(false);
//     toast.success(
//       `‚úÖ Step added with ${type?.replace("_", " ") || "template"}`
//     );
//     setTimeout(() => fitView({ padding: 0.2 }), 50);
//   };

//   // -------- Connection policy (pro-grade) --------
//   const isValidConnection = useCallback(
//     params => {
//       // Only one edge per (source, sourceHandle)
//       if (!params?.source || !params?.sourceHandle) return false;
//       const duplicate = edges.some(
//         e =>
//           e.source === params.source && e.sourceHandle === params.sourceHandle
//       );
//       return !duplicate;
//     },
//     [edges]
//   );

//   const onConnect = useCallback(
//     params => {
//       if (readonly) return;

//       // Label the edge with the handle (button text)
//       const label = params.sourceHandle || "";

//       // Visual edge
//       setEdges(eds =>
//         addEdge(
//           {
//             ...params,
//             id: uuidv4(),
//             type: "smoothstep",
//             animated: true,
//             style: { stroke: "#9333ea" },
//             markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
//             label,
//             labelStyle: { fontSize: 10, fill: "#4b5563" },
//             labelBgPadding: [4, 2],
//             labelBgBorderRadius: 4,
//             labelBgStyle: { fill: "#ffffff" },
//           },
//           eds
//         )
//       );

//       // Semantic link: tie edge to the specific button on source node
//       setNodes(nds =>
//         nds.map(node => {
//           if (node.id !== params.source) return node;

//           const sourceHandle = params.sourceHandle || "";
//           let updatedButtons = [...(node.data.buttons || [])];

//           // Find the button matching the handle (by text)
//           const idxByHandle = updatedButtons.findIndex(
//             b =>
//               (b.text || "").toLowerCase().trim() ===
//               sourceHandle.toLowerCase().trim()
//           );

//           if (idxByHandle >= 0) {
//             updatedButtons[idxByHandle] = {
//               ...updatedButtons[idxByHandle],
//               targetNodeId: params.target,
//             };
//           } else {
//             // Fallback: link the first unlinked button
//             const idxFirstUnlinked = updatedButtons.findIndex(
//               b => !b.targetNodeId
//             );
//             if (idxFirstUnlinked >= 0) {
//               updatedButtons[idxFirstUnlinked] = {
//                 ...updatedButtons[idxFirstUnlinked],
//                 targetNodeId: params.target,
//               };
//             }
//           }
//           return { ...node, data: { ...node.data, buttons: updatedButtons } };
//         })
//       );
//     },
//     [readonly, setEdges, setNodes]
//   );

//   // -------- Keyboard UX --------
//   useEffect(() => {
//     const onKey = e => {
//       if (readonly) return;
//       if (e.key === "Delete" || e.key === "Backspace") {
//         setNodes(nds => nds.filter(n => !n.selected));
//         setEdges(eds => eds.filter(ed => !ed.selected));
//       }
//       if (e.key === "Escape") {
//         setNodes(nds => nds.map(n => ({ ...n, selected: false })));
//         setEdges(eds => eds.map(ed => ({ ...ed, selected: false })));
//       }
//     };
//     window.addEventListener("keydown", onKey);
//     return () => window.removeEventListener("keydown", onKey);
//   }, [readonly, setNodes, setEdges]);

//   // -------- Auto-layout (dagre) --------
//   const applyLayout = useCallback(
//     (direction = "LR") => {
//       const g = new dagre.graphlib.Graph();
//       g.setGraph({
//         rankdir: direction, // LR (left->right) or TB (top->bottom)
//         nodesep: 50,
//         ranksep: 90,
//         marginx: 20,
//         marginy: 20,
//       });
//       g.setDefaultEdgeLabel(() => ({}));

//       // seed nodes with approx size
//       nodes.forEach(n => {
//         const width = n?.measured?.width || NODE_DEFAULT.width;
//         const height = n?.measured?.height || NODE_DEFAULT.height;
//         g.setNode(n.id, { width, height });
//       });
//       edges.forEach(e => g.setEdge(e.source, e.target));

//       dagre.layout(g);

//       const laidOut = nodes.map(n => {
//         const { x, y } = g.node(n.id);
//         const width = n?.measured?.width || NODE_DEFAULT.width;
//         const height = n?.measured?.height || NODE_DEFAULT.height;
//         return {
//           ...n,
//           position: { x: x - width / 2, y: y - height / 2 },
//         };
//       });

//       setNodes(laidOut);
//       setTimeout(() => fitView({ padding: 0.2 }), 50);
//     },
//     [nodes, edges, setNodes, fitView]
//   );

//   // -------- Save --------
//   const handleSave = async isPublished => {
//     try {
//       // Transform nodes with stable Index per button
//       const transformedNodes = nodes
//         .filter(n => n?.data?.templateName)
//         .map(node => ({
//           Id: node.id || uuidv4(),
//           TemplateName: node?.data?.templateName || "Untitled",
//           TemplateType: node?.data?.templateType || "text_template",
//           MessageBody: node?.data?.messageBody || "",
//           PositionX: node.position?.x || 0,
//           PositionY: node.position?.y || 0,
//           TriggerButtonText: node?.data?.triggerButtonText || "",
//           TriggerButtonType: node?.data?.triggerButtonType || "cta",
//           RequiredTag: node?.data?.requiredTag || "",
//           RequiredSource: node?.data?.requiredSource || "",
//           Buttons: (node?.data?.buttons || [])
//             .filter(btn => (btn.text || "").trim().length > 0)
//             .map((btn, idx) => ({
//               Text: (btn.text || "").trim(),
//               Type: btn.type || "QUICK_REPLY",
//               SubType: btn.subType || "",
//               Value: btn.value || "",
//               TargetNodeId: btn.targetNodeId || null,
//               Index: typeof btn.index === "number" ? btn.index : idx,
//             })),
//         }));

//       const transformedEdges = edges.map(edge => ({
//         FromNodeId: edge.source,
//         ToNodeId: edge.target,
//         SourceHandle: edge.sourceHandle || "", // should match Button Text
//       }));

//       const payload = {
//         FlowName: flowName || "Untitled",
//         IsPublished: isPublished ?? false,
//         Nodes: transformedNodes,
//         Edges: transformedEdges,
//       };

//       console.log("üì§ Final Payload to POST:", payload);
//       await saveVisualFlow(payload);
//       toast.success("‚úÖ Flow saved successfully");
//     } catch (error) {
//       console.error("‚ùå Save flow failed: ", error);
//       toast.error("‚ùå Failed to save flow");
//     }
//   };

//   // -------- Default edge appearance --------
//   const defaultEdgeOptions = useMemo(
//     () => ({
//       type: "smoothstep",
//       animated: true,
//       style: { stroke: "#9333ea" },
//       markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
//     }),
//     []
//   );

//   return (
//     <div className="p-6">
//       {/* Header */}
//       <div className="flex justify-between items-center mb-4">
//         <h2 className="text-2xl font-bold text-purple-700">
//           üß† CTA Flow Visual Builder
//         </h2>

//         {!readonly && (
//           <div className="flex items-center gap-2 flex-wrap">
//             <input
//               id="flowName"
//               name="flowName"
//               ref={flowNameRef}
//               value={flowName}
//               onChange={e => setFlowName(e.target.value)}
//               placeholder="Add flow name"
//               className="border border-gray-300 px-3 py-2 rounded-md shadow-sm text-sm"
//             />
//             <button
//               onClick={() => setShowPicker(true)}
//               className="bg-purple-600 text-white px-4 py-2 rounded shadow hover:bg-purple-700 text-sm"
//             >
//               ‚ûï Add Step
//             </button>
//             <button
//               onClick={() => navigate("/app/cta-flow/flow-manager")}
//               className="bg-white border border-purple-600 text-purple-700 font-medium text-sm px-4 py-2 rounded-md shadow-sm hover:bg-purple-50"
//             >
//               ‚Ü©Ô∏è Manage All Flows
//             </button>
//           </div>
//         )}
//       </div>

//       {/* Canvas */}
//       <div className="h-[70vh] border rounded-xl bg-gray-50 relative">
//         {/* Minimap toggle */}
//         <div className="absolute bottom-5 right-4 z-50 flex gap-2">
//           <button
//             onClick={() => setShowMiniMap(prev => !prev)}
//             className="bg-purple-600 text-white p-2 rounded-full shadow hover:bg-purple-700"
//             title={showMiniMap ? "Hide MiniMap" : "Show MiniMap"}
//           >
//             {showMiniMap ? <Minus size={15} /> : <Eye size={15} />}
//           </button>

//           {/* Fit / Zoom / Auto-layout */}
//           <div className="flex items-center gap-2 bg-white/90 px-2 py-1 rounded-full border">
//             <button
//               onClick={() => fitView({ padding: 0.2 })}
//               className="text-xs px-2 py-1 rounded hover:bg-gray-100"
//               title="Fit"
//             >
//               Fit
//             </button>
//             <button
//               onClick={() => zoomIn()}
//               className="text-xs px-2 py-1 rounded hover:bg-gray-100"
//               title="Zoom In"
//             >
//               +
//             </button>
//             <button
//               onClick={() => zoomOut()}
//               className="text-xs px-2 py-1 rounded hover:bg-gray-100"
//               title="Zoom Out"
//             >
//               ‚àí
//             </button>
//             {!readonly && (
//               <>
//                 <button
//                   onClick={() => applyLayout("LR")}
//                   className="text-xs px-2 py-1 rounded hover:bg-gray-100"
//                   title="Auto-layout (Left‚ÜíRight)"
//                 >
//                   Auto LR
//                 </button>
//                 <button
//                   onClick={() => applyLayout("TB")}
//                   className="text-xs px-2 py-1 rounded hover:bg-gray-100"
//                   title="Auto-layout (Top‚ÜíBottom)"
//                 >
//                   Auto TB
//                 </button>
//               </>
//             )}
//           </div>
//         </div>

//         <ReactFlow
//           nodes={nodes}
//           edges={edges}
//           onNodesChange={onNodesChange}
//           onEdgesChange={onEdgesChange}
//           onConnect={onConnect}
//           onEdgeClick={(e, edge) => {
//             if (!readonly) setEdges(eds => eds.filter(ed => ed.id !== edge.id));
//           }}
//           nodeTypes={nodeTypes}
//           fitView
//           fitViewOptions={{ padding: 0.2 }}
//           defaultEdgeOptions={defaultEdgeOptions}
//           // ‚ú® Pro feel
//           connectionMode={ConnectionMode.Strict}
//           isValidConnection={isValidConnection}
//           snapToGrid
//           snapGrid={[GRID, GRID]}
//           panOnScroll
//           zoomOnPinch
//           panOnDrag={[1, 2]} // allow panning from empty space & ctrl/shift drag
//           selectionOnDrag
//           nodesDraggable={!readonly}
//           nodesConnectable={!readonly}
//           elementsSelectable={!readonly}
//           // keep sourceHandle label visible in edge labels
//         >
//           {showMiniMap && (
//             <MiniMap
//               nodeColor="#9333ea"
//               nodeStrokeWidth={2}
//               maskColor="rgba(255,255,255,0.6)"
//             />
//           )}
//           <Controls />
//           <Background variant="dots" gap={GRID} size={1} />
//         </ReactFlow>
//       </div>

//       {/* Footer actions */}
//       {!readonly && (
//         <div className="mt-6 flex gap-4">
//           <button
//             onClick={() => handleSave(false)}
//             className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm"
//           >
//             üíæ Save Draft
//           </button>
//           <button
//             onClick={() => handleSave(true)}
//             className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-sm"
//           >
//             üöÄ Publish Flow
//           </button>
//         </div>
//       )}

//       <TemplatePickerModal
//         open={showPicker}
//         onClose={() => setShowPicker(false)}
//         onSelect={handleTemplateSelect}
//       />
//     </div>
//   );
// }

// export default function CTAFlowVisualBuilder() {
//   return (
//     <ReactFlowProvider>
//       <CTAFlowVisualBuilderInner />
//     </ReactFlowProvider>
//   );
// }

// import React, {
//   useCallback,
//   useState,
//   useEffect,
//   useMemo,
//   useRef,
// } from "react";
// import {
//   ReactFlow,
//   ReactFlowProvider,
//   Background,
//   Controls,
//   MiniMap,
//   useNodesState,
//   useEdgesState,
//   addEdge,
//   MarkerType,
// } from "@xyflow/react";
// import "@xyflow/react/dist/style.css";
// import { Eye, Minus } from "lucide-react";
// import { useSearchParams, useNavigate } from "react-router-dom";
// import TemplatePickerModal from "./components/TemplatePickerModal";
// import FlowNodeBubble from "./components/FlowNodeBubble";
// import { saveVisualFlow, getVisualFlowById } from "./ctaFlowVisualApi";
// import { v4 as uuidv4 } from "uuid";
// import { toast } from "react-toastify";

// function CTAFlowVisualBuilderInner() {
//   const [nodes, setNodes, onNodesChange] = useNodesState([]);
//   const [edges, setEdges, onEdgesChange] = useEdgesState([]);
//   const nodesRef = useRef([]);
//   const [showPicker, setShowPicker] = useState(false);
//   const [flowName, setFlowName] = useState("");
//   const flowNameRef = useRef(null);
//   const [showMiniMap, setShowMiniMap] = useState(false);
//   const [readonly, setReadonly] = useState(false);
//   const [searchParams] = useSearchParams();
//   const navigate = useNavigate();
//   const mode = searchParams.get("mode");
//   const flowId = searchParams.get("id");
//   const visualDebug = true;

//   useEffect(() => {
//     nodesRef.current = [...nodes];
//   }, [nodes]);

//   const handleDeleteNode = useCallback(
//     nodeId => {
//       if (readonly) return;
//       setNodes(nds => nds.filter(n => n.id !== nodeId));
//       setEdges(eds =>
//         eds.filter(e => e.source !== nodeId && e.target !== nodeId)
//       );
//     },
//     [readonly, setNodes, setEdges]
//   );

//   const handleNodeDataChange = useCallback(
//     (nodeId, newData) => {
//       setNodes(nds =>
//         nds.map(n =>
//           n.id === nodeId ? { ...n, data: { ...n.data, ...newData } } : n
//         )
//       );
//     },
//     [setNodes]
//   );

//   const nodeTypes = useMemo(
//     () => ({
//       customBubble: props => (
//         <FlowNodeBubble
//           {...props}
//           onDelete={handleDeleteNode}
//           onDataChange={newData => handleNodeDataChange(props.id, newData)}
//           readonly={readonly}
//           visualDebug={visualDebug}
//         />
//       ),
//     }),
//     [handleDeleteNode, readonly, visualDebug, handleNodeDataChange]
//   );

//   useEffect(() => {
//     const load = async () => {
//       if (mode === "edit" || mode === "view") {
//         try {
//           const data = await getVisualFlowById(flowId);

//           const builtNodes = data.nodes.map((node, index) => ({
//             id: node.id,
//             type: "customBubble",
//             position: {
//               x: node.positionX ?? 120 + index * 120,
//               y: node.positionY ?? 150 + (index % 5) * 60,
//             },
//             data: {
//               templateName: node.templateName,
//               templateType: node.templateType,
//               messageBody: node.messageBody,
//               triggerButtonText: node.triggerButtonText || "",
//               triggerButtonType: node.triggerButtonType || "cta",
//               requiredTag: node.requiredTag || "",
//               requiredSource: node.requiredSource || "",
//               // keep button order and include index if backend returned one
//               buttons: (node.buttons || []).map((btn, i) => ({
//                 text: btn.text,
//                 type: btn.type,
//                 subType: btn.subType,
//                 value: btn.value,
//                 targetNodeId: btn.targetNodeId || null,
//                 index: typeof btn.index === "number" ? btn.index : i, // <-- include index in UI state
//               })),
//             },
//           }));

//           const builtEdges = data.edges.map(edge => ({
//             id: `e-${edge.fromNodeId}-${edge.toNodeId}-${
//               edge.sourceHandle || "h"
//             }`,
//             source: edge.fromNodeId,
//             target: edge.toNodeId,
//             sourceHandle: edge.sourceHandle || null, // this should equal the button text
//             type: "smoothstep",
//             animated: true,
//             style: { stroke: "#9333ea" },
//             markerEnd: { type: "arrowclosed", color: "#9333ea" },
//           }));

//           // üîç Detect nodes with no incoming edges (often entry nodes; this is informational)
//           const nodesWithIncoming = new Set(builtEdges.map(e => e.target));
//           const nodesWithWarnings = builtNodes.map(node => ({
//             ...node,
//             data: {
//               ...node.data,
//               isUnreachable: false, // we won't block save on this for now
//               hasNoIncoming: !nodesWithIncoming.has(node.id),
//             },
//           }));

//           setNodes(nodesWithWarnings);
//           setEdges(builtEdges);
//           setFlowName(data.flowName);
//           if (mode === "view") setReadonly(true);
//         } catch {
//           toast.error("‚ùå Failed to load flow");
//         }
//       } else {
//         setNodes([]);
//         setEdges([]);
//         setFlowName("Untitled Flow");
//         setReadonly(false);
//       }
//     };

//     load();
//   }, [flowId, mode, setNodes, setEdges]);

//   const handleTemplateSelect = ({ name, type, body, buttons = [] }) => {
//     const id = uuidv4();
//     const newNode = {
//       id,
//       position: {
//         x: Math.random() * 400 + 100,
//         y: Math.random() * 300 + 100,
//       },
//       type: "customBubble",
//       data: {
//         templateName: name || "Untitled",
//         templateType: type || "text_template",
//         messageBody: body || "Message body preview...",
//         triggerButtonText: buttons[0]?.text || "",
//         triggerButtonType: "cta",
//         // ensure we keep button order & store index for each
//         buttons: buttons.map((btn, idx) => ({
//           text: btn.text || "",
//           type: btn.type || "QUICK_REPLY",
//           subType: btn.subType || "",
//           value: btn.parameterValue || "",
//           targetNodeId: null,
//           index: idx, // <-- tracked in UI so we can send Index later
//         })),
//       },
//     };
//     setNodes(nds => [...nds, newNode]);
//     setShowPicker(false);
//     toast.success(
//       `‚úÖ Step added with ${type?.replace("_", " ") || "template"}`
//     );
//   };

//   const onConnect = useCallback(
//     params => {
//       if (readonly) return;

//       // Add the visual edge
//       setEdges(eds =>
//         addEdge(
//           {
//             ...params,
//             id: uuidv4(),
//             type: "smoothstep",
//             animated: true,
//             style: { stroke: "#9333ea" },
//             markerEnd: { type: MarkerType.ArrowClosed, color: "#9333ea" },
//           },
//           eds
//         )
//       );

//       // IMPORTANT: tie the edge to the specific button on the source node
//       setNodes(nds =>
//         nds.map(node => {
//           if (node.id !== params.source) return node;

//           const sourceHandle = params.sourceHandle || ""; // should equal button text
//           let updatedButtons = [...(node.data.buttons || [])];

//           // Try to find the button that matches the handle (by text)
//           const idxByHandle = updatedButtons.findIndex(
//             b =>
//               (b.text || "").toLowerCase().trim() ===
//               sourceHandle.toLowerCase().trim()
//           );

//           if (idxByHandle >= 0) {
//             updatedButtons[idxByHandle] = {
//               ...updatedButtons[idxByHandle],
//               targetNodeId: params.target,
//             };
//           } else {
//             // Fallback: link the first unlinked button
//             const idxFirstUnlinked = updatedButtons.findIndex(
//               b => !b.targetNodeId
//             );
//             if (idxFirstUnlinked >= 0) {
//               updatedButtons[idxFirstUnlinked] = {
//                 ...updatedButtons[idxFirstUnlinked],
//                 targetNodeId: params.target,
//               };
//             }
//           }

//           return { ...node, data: { ...node.data, buttons: updatedButtons } };
//         })
//       );
//     },
//     [readonly, setEdges, setNodes]
//   );

//   // --- Save ---

//   const handleSave = async isPublished => {
//     try {
//       // ‚úÖ Transform nodes with stable Index per button
//       const transformedNodes = nodes
//         .filter(n => n?.data?.templateName)
//         .map(node => ({
//           Id: node.id || uuidv4(),
//           TemplateName: node?.data?.templateName || "Untitled",
//           TemplateType: node?.data?.templateType || "text_template",
//           MessageBody: node?.data?.messageBody || "",
//           PositionX: node.position?.x || 0,
//           PositionY: node.position?.y || 0,
//           TriggerButtonText: node?.data?.triggerButtonText || "",
//           TriggerButtonType: node?.data?.triggerButtonType || "cta",
//           RequiredTag: node?.data?.requiredTag || "",
//           RequiredSource: node?.data?.requiredSource || "",
//           Buttons: (node?.data?.buttons || [])
//             .filter(btn => (btn.text || "").trim().length > 0)
//             .map((btn, idx) => ({
//               Text: (btn.text || "").trim(),
//               Type: btn.type || "QUICK_REPLY",
//               SubType: btn.subType || "",
//               Value: btn.value || "",
//               TargetNodeId: btn.targetNodeId || null,
//               Index: typeof btn.index === "number" ? btn.index : idx, // <-- send Index explicitly
//             })),
//         }));

//       const transformedEdges = edges.map(edge => ({
//         FromNodeId: edge.source,
//         ToNodeId: edge.target,
//         SourceHandle: edge.sourceHandle || "", // should match Button Text
//       }));

//       const payload = {
//         FlowName: flowName || "Untitled",
//         IsPublished: isPublished ?? false,
//         Nodes: transformedNodes,
//         Edges: transformedEdges,
//       };

//       console.log("üì§ Final Payload to POST:", payload);
//       await saveVisualFlow(payload);
//       toast.success("‚úÖ Flow saved successfully");
//     } catch (error) {
//       console.error("‚ùå Save flow failed: ", error);
//       toast.error("‚ùå Failed to save flow");
//     }
//   };

//   return (
//     <div className="p-6">
//       <div className="flex justify-between items-center mb-4">
//         <h2 className="text-2xl font-bold text-purple-700">
//           üß† CTA Flow Visual Builder
//         </h2>
//         {!readonly && (
//           <div className="flex items-center gap-4">
//             <input
//               id="flowName"
//               name="flowName"
//               ref={flowNameRef}
//               value={flowName}
//               onChange={e => setFlowName(e.target.value)}
//               placeholder="Add flow name"
//               className="border border-gray-300 px-3 py-2 rounded-md shadow-sm text-sm"
//             />
//             <button
//               onClick={() => setShowPicker(true)}
//               className="bg-purple-600 text-white px-4 py-2 rounded shadow hover:bg-purple-700 text-sm"
//             >
//               ‚ûï Add Step
//             </button>
//             <button
//               onClick={() => navigate("/app/cta-flow/flow-manager")}
//               className="bg-white border border-purple-600 text-purple-700 font-medium text-sm px-4 py-2 rounded-md shadow-sm hover:bg-purple-50"
//             >
//               ‚Ü©Ô∏è Manage All Flows
//             </button>
//           </div>
//         )}
//       </div>

//       <div className="h-[70vh] border rounded-xl bg-gray-50 relative">
//         <div className="absolute bottom-5 right-4 z-50">
//           <button
//             onClick={() => setShowMiniMap(prev => !prev)}
//             className="bg-purple-600 text-white p-2 rounded-full shadow hover:bg-purple-700"
//             title={showMiniMap ? "Hide MiniMap" : "Show MiniMap"}
//           >
//             {showMiniMap ? <Minus size={15} /> : <Eye size={15} />}
//           </button>
//         </div>

//         <ReactFlow
//           nodes={nodes}
//           edges={edges}
//           onNodesChange={onNodesChange}
//           onEdgesChange={onEdgesChange}
//           onConnect={onConnect}
//           onEdgeClick={(e, edge) => {
//             if (!readonly) setEdges(eds => eds.filter(ed => ed.id !== edge.id));
//           }}
//           nodeTypes={nodeTypes}
//           fitView
//         >
//           {showMiniMap && (
//             <MiniMap
//               nodeColor="#9333ea"
//               nodeStrokeWidth={2}
//               maskColor="rgba(255,255,255,0.6)"
//             />
//           )}
//           <Controls />
//           <Background />
//         </ReactFlow>
//       </div>

//       {!readonly && (
//         <div className="mt-6 flex gap-4">
//           <button
//             onClick={() => handleSave(false)}
//             className="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700 text-sm"
//           >
//             üíæ Save Draft
//           </button>
//           <button
//             onClick={() => handleSave(true)}
//             className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-sm"
//           >
//             üöÄ Publish Flow
//           </button>
//         </div>
//       )}

//       <TemplatePickerModal
//         open={showPicker}
//         onClose={() => setShowPicker(false)}
//         onSelect={handleTemplateSelect}
//       />
//     </div>
//   );
// }

// export default function CTAFlowVisualBuilder() {
//   return (
//     <ReactFlowProvider>
//       <CTAFlowVisualBuilderInner />
//     </ReactFlowProvider>
//   );
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\CTAFlowVisualBuilder_AllFileDump.txt 
====================================================== 
 
Folder and File Content Report
 
========================== 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\ExtrackAllFiles.bat 
====================================================== 
 
@echo off
REM This script will find all files and output their name and content into one file.
REM The output file will be named [FolderName]_AllFileDump.txt.

REM Get the current folder's name and set it as the output file name with the custom suffix
for %%I in ("%cd%") do set "outputFile=%%~nI_AllFileDump.txt"

REM Clear the output file to start fresh
> "%outputFile%" (echo Folder and File Content Report)
echo. >> "%outputFile%"

REM Loop through all files in the current directory and subdirectories
for /R . %%F in (*.*) do (
    echo ====================================================== >> "%outputFile%"
    echo FILE: %%F >> "%outputFile%"
    echo ====================================================== >> "%outputFile%"
    echo. >> "%outputFile%"
    type "%%F" >> "%outputFile%" 2>nul
    echo. >> "%outputFile%"
    echo. >> "%outputFile%"
)

echo Finished! All content has been extracted to %outputFile% 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\components\FlowNodeBubble.jsx 
====================================================== 
 
import React, { useEffect } from "react";
import { Handle, Position } from "@xyflow/react";
import { X, MessageSquare } from "lucide-react";

export default function FlowNodeBubble({
  id,
  data,
  onDelete,
  readonly,
  onDataChange,
  visualDebug = false, // not rendered
}) {
  const {
    templateName,
    messageBody,
    buttons = [],
    requiredTag,
    requiredSource,
    isUnreachable,
  } = data;

  // Keep trigger info in sync with first button
  useEffect(() => {
    if (buttons.length > 0 && onDataChange) {
      const triggerText = buttons[0]?.text || "";
      onDataChange({
        ...data,
        triggerButtonText: triggerText,
        triggerButtonType: "cta",
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [buttons]);

  return (
    <div className="bg-white shadow-md rounded-xl border border-purple-200 w-72 p-4 relative">
      {/* ‚ùå Delete */}
      {!readonly && (
        <button
          onClick={() => onDelete(id)}
          className="absolute top-1.5 right-1.5 text-red-500 hover:text-red-700"
          title="Delete this step"
          aria-label="Delete step"
        >
          <X size={16} />
        </button>
      )}

      {/* ‚ö†Ô∏è Warning */}
      {isUnreachable && (
        <div
          className="text-xs text-red-600 bg-red-100 px-2 py-0.5 rounded-full font-semibold mb-2 inline-block"
          title="This step has no incoming trigger. It may never run."
        >
          ‚ö†Ô∏è Unreachable Step
        </div>
      )}

      {/* Header ‚Äî minimal (icon + name) with divider */}
      <div className="mb-2">
        <div className="flex items-center gap-2 pb-2 border-b border-gray-200">
          <MessageSquare
            size={16}
            className="text-purple-600 shrink-0"
            aria-hidden
          />
          <div
            className="min-w-0 truncate text-sm font-medium text-gray-900"
            title={templateName || "Untitled Step"}
          >
            {templateName || "Untitled Step"}
          </div>
        </div>
      </div>

      {/* üí¨ Body ‚Äî scrollable to avoid crowding */}
      <div
        className="text-sm text-gray-700 whitespace-pre-wrap mb-3 overflow-y-auto"
        style={{
          maxHeight: 180, // control the vertical footprint
          overscrollBehavior: "contain",
          scrollbarWidth: "thin", // Firefox
          WebkitOverflowScrolling: "touch", // iOS momentum
        }}
        title={messageBody}
      >
        üí¨ {messageBody || "Message body preview..."}
      </div>

      {/* üéØ Badges */}
      <div className="flex flex-wrap gap-2 mb-2">
        {!!requiredTag && (
          <span
            className="bg-yellow-100 text-yellow-800 text-[10px] px-2 py-0.5 rounded-full font-semibold"
            title={`Only contacts with tag "${requiredTag}" will receive this step.`}
          >
            üéØ Tag: {requiredTag}
          </span>
        )}
        {!!requiredSource && (
          <span
            className="bg-purple-100 text-purple-800 text-[10px] px-2 py-0.5 rounded-full font-semibold"
            title={`This step runs only if Source = "${requiredSource}"`}
          >
            üîó Source: {requiredSource}
          </span>
        )}
      </div>

      {/* üîò Buttons + source handles (no connection status UI) */}
      <div className="flex flex-col gap-2">
        {buttons.map((btn, index) => {
          const text = (btn.text || "").trim() || `Button ${index + 1}`;
          return (
            <div
              key={`${text}-${index}`}
              className="relative bg-purple-100 text-purple-800 text-xs px-3 py-1 rounded shadow-sm"
              title={text}
            >
              <div className="pr-6 text-center select-none">üîò {text}</div>

              {/* Right source handle (enlarged hit area) */}
              <Handle
                type="source"
                position={Position.Right}
                id={text} // keep equal to button text for mapping
                title={`Drag to connect: ${text}`}
                aria-label={`Connect from ${text}`}
                style={{
                  background: "#9333ea",
                  right: "-10px",
                  top: "50%",
                  transform: "translateY(-50%)",
                  width: 16,
                  height: 16,
                  border: "2px solid #fff",
                  borderRadius: 9999,
                  boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
                  cursor: "crosshair",
                }}
              />
              {/* Invisible larger hotspot to make grabbing easier */}
              <div
                style={{
                  position: "absolute",
                  right: -18,
                  top: "50%",
                  transform: "translateY(-50%)",
                  width: 36,
                  height: 28,
                  background: "transparent",
                  pointerEvents: "none",
                }}
              />
            </div>
          );
        })}
      </div>

      {/* üü£ Fallback source if no buttons */}
      {buttons.length === 0 && (
        <Handle
          type="source"
          position={Position.Bottom}
          id="default"
          title="Drag to connect"
          style={{
            background: "#9333ea",
            width: 16,
            height: 16,
            border: "2px solid #fff",
            borderRadius: 9999,
            boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
          }}
        />
      )}

      {/* üîµ Incoming target */}
      <Handle
        type="target"
        position={Position.Top}
        id="incoming"
        title="Drop a connection here"
        style={{
          background: "#9333ea",
          width: 16,
          height: 16,
          border: "2px solid #fff",
          borderRadius: 9999,
          boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
        }}
      />
    </div>
  );
}

// import React, { useEffect } from "react";
// import { Handle, Position } from "@xyflow/react";
// import { X, MessageSquare } from "lucide-react";

// export default function FlowNodeBubble({
//   id,
//   data,
//   onDelete,
//   readonly,
//   onDataChange,
//   visualDebug = false, // kept for parity; no debug UI rendered
// }) {
//   const {
//     templateName,
//     messageBody,
//     buttons = [],
//     requiredTag,
//     requiredSource,
//     isUnreachable,
//   } = data;

//   // Keep trigger info in sync with first button
//   useEffect(() => {
//     if (buttons.length > 0 && onDataChange) {
//       const triggerText = buttons[0]?.text || "";
//       onDataChange({
//         ...data,
//         triggerButtonText: triggerText,
//         triggerButtonType: "cta",
//       });
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [buttons]);

//   return (
//     <div className="bg-white shadow-md rounded-xl border border-purple-200 w-72 p-4 relative">
//       {/* ‚ùå Delete */}
//       {!readonly && (
//         <button
//           onClick={() => onDelete(id)}
//           className="absolute top-1.5 right-1.5 text-red-500 hover:text-red-700"
//           title="Delete this step"
//           aria-label="Delete step"
//         >
//           <X size={16} />
//         </button>
//       )}

//       {/* ‚ö†Ô∏è Warning */}
//       {isUnreachable && (
//         <div
//           className="text-xs text-red-600 bg-red-100 px-2 py-0.5 rounded-full font-semibold mb-2 inline-block"
//           title="This step has no incoming trigger. It may never run."
//         >
//           ‚ö†Ô∏è Unreachable Step
//         </div>
//       )}

//       {/* Header ‚Äî minimal (icon + name) */}
//       <div className="mb-2 flex items-center gap-2">
//         <MessageSquare
//           size={16}
//           className="text-purple-600 shrink-0"
//           aria-hidden
//         />
//         <div
//           className="min-w-0 truncate text-sm font-medium text-gray-900"
//           title={templateName || "Untitled Step"}
//         >
//           {templateName || "Untitled Step"}
//         </div>
//       </div>

//       {/* üí¨ Body */}
//       <div
//         className="text-sm text-gray-700 whitespace-pre-wrap mb-3"
//         style={{ maxHeight: 140, overflow: "auto" }}
//         title={messageBody}
//       >
//         üí¨ {messageBody || "Message body preview..."}
//       </div>

//       {/* üéØ Badges */}
//       <div className="flex flex-wrap gap-2 mb-2">
//         {!!requiredTag && (
//           <span
//             className="bg-yellow-100 text-yellow-800 text-[10px] px-2 py-0.5 rounded-full font-semibold"
//             title={`Only contacts with tag "${requiredTag}" will receive this step.`}
//           >
//             üéØ Tag: {requiredTag}
//           </span>
//         )}
//         {!!requiredSource && (
//           <span
//             className="bg-purple-100 text-purple-800 text-[10px] px-2 py-0.5 rounded-full font-semibold"
//             title={`This step runs only if Source = "${requiredSource}"`}
//           >
//             üîó Source: {requiredSource}
//           </span>
//         )}
//       </div>

//       {/* üîò Buttons + source handles (no connection status UI) */}
//       <div className="flex flex-col gap-2">
//         {buttons.map((btn, index) => {
//           const text = (btn.text || "").trim() || `Button ${index + 1}`;
//           return (
//             <div
//               key={`${text}-${index}`}
//               className="relative bg-purple-100 text-purple-800 text-xs px-3 py-1 rounded shadow-sm"
//               title={text}
//             >
//               <div className="pr-6 text-center select-none">üîò {text}</div>

//               {/* Right source handle (enlarged hit area) */}
//               <Handle
//                 type="source"
//                 position={Position.Right}
//                 id={text} // keep equal to button text for mapping
//                 title={`Drag to connect: ${text}`}
//                 aria-label={`Connect from ${text}`}
//                 style={{
//                   background: "#9333ea",
//                   right: "-10px",
//                   top: "50%",
//                   transform: "translateY(-50%)",
//                   width: 16,
//                   height: 16,
//                   border: "2px solid #fff",
//                   borderRadius: 9999,
//                   boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
//                   cursor: "crosshair",
//                 }}
//               />
//               {/* Invisible larger hotspot to make grabbing easier */}
//               <div
//                 style={{
//                   position: "absolute",
//                   right: -18,
//                   top: "50%",
//                   transform: "translateY(-50%)",
//                   width: 36,
//                   height: 28,
//                   background: "transparent",
//                   pointerEvents: "none",
//                 }}
//               />
//             </div>
//           );
//         })}
//       </div>

//       {/* üü£ Fallback source if no buttons */}
//       {buttons.length === 0 && (
//         <Handle
//           type="source"
//           position={Position.Bottom}
//           id="default"
//           title="Drag to connect"
//           style={{
//             background: "#9333ea",
//             width: 16,
//             height: 16,
//             border: "2px solid #fff",
//             borderRadius: 9999,
//             boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
//           }}
//         />
//       )}

//       {/* üîµ Incoming target */}
//       <Handle
//         type="target"
//         position={Position.Top}
//         id="incoming"
//         title="Drop a connection here"
//         style={{
//           background: "#9333ea",
//           width: 16,
//           height: 16,
//           border: "2px solid #fff",
//           borderRadius: 9999,
//           boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
//         }}
//       />
//     </div>
//   );
// }

// import React, { useEffect } from "react";
// import { Handle, Position } from "@xyflow/react";
// import { X } from "lucide-react";

// export default function FlowNodeBubble({
//   id,
//   data,
//   onDelete,
//   readonly,
//   onDataChange,
//   visualDebug = false, // kept for API parity; no debug UI rendered
// }) {
//   const {
//     templateName,
//     messageBody,
//     buttons = [],
//     requiredTag,
//     requiredSource,
//     isUnreachable,
//   } = data;

//   // Keep trigger info in sync with first button
//   useEffect(() => {
//     if (buttons.length > 0 && onDataChange) {
//       const triggerText = buttons[0]?.text || "";
//       onDataChange({
//         ...data,
//         triggerButtonText: triggerText,
//         triggerButtonType: "cta",
//       });
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [buttons]);

//   return (
//     <div className="bg-white shadow-md rounded-xl border border-purple-200 w-72 p-4 relative">
//       {/* ‚ùå Delete */}
//       {!readonly && (
//         <button
//           onClick={() => onDelete(id)}
//           className="absolute top-1.5 right-1.5 text-red-500 hover:text-red-700"
//           title="Delete this step"
//           aria-label="Delete step"
//         >
//           <X size={16} />
//         </button>
//       )}

//       {/* ‚ö†Ô∏è Warning */}
//       {isUnreachable && (
//         <div
//           className="text-xs text-red-600 bg-red-100 px-2 py-0.5 rounded-full font-semibold mb-2 inline-block"
//           title="This step has no incoming trigger. It may never run."
//         >
//           ‚ö†Ô∏è Unreachable Step
//         </div>
//       )}

//       {/* üßæ Header */}
//       {/* <div className="font-bold text-purple-700 mb-2">
//         üì¶ {templateName || "Untitled Step"}
//       </div> */}
//       {/* Header (clean title bar) */}
//       <div className="mb-3 -mt-1">
//         <div className="flex items-center gap-2 rounded-lg border border-purple-100 bg-gradient-to-r from-purple-50 to-white px-2.5 py-1.5">
//           {/* icon badge */}
//           <div
//             className="inline-flex h-6 w-6 items-center justify-center rounded-md bg-purple-100 text-purple-700 ring-1 ring-purple-200"
//             aria-hidden
//           >
//             {/* tiny message bubble icon (emoji keeps bundle light) */}
//             <span className="text-[12px]">üí¨</span>
//           </div>

//           {/* name (truncated with tooltip) */}
//           <div
//             className="min-w-0 text-sm font-semibold text-gray-900 truncate"
//             title={templateName || "Untitled Step"}
//           >
//             {templateName || "Untitled Step"}
//           </div>
//         </div>
//       </div>

//       {/* üí¨ Body (soft clamp to keep node height stable) */}
//       <div
//         className="text-sm text-gray-700 whitespace-pre-wrap mb-3"
//         style={{ maxHeight: 140, overflow: "auto" }}
//         title={messageBody}
//       >
//         üí¨ {messageBody || "Message body preview..."}
//       </div>

//       {/* üéØ Badges */}
//       <div className="flex flex-wrap gap-2 mb-2">
//         {!!requiredTag && (
//           <span
//             className="bg-yellow-100 text-yellow-800 text-[10px] px-2 py-0.5 rounded-full font-semibold"
//             title={`Only contacts with tag "${requiredTag}" will receive this step.`}
//           >
//             üéØ Tag: {requiredTag}
//           </span>
//         )}
//         {!!requiredSource && (
//           <span
//             className="bg-purple-100 text-purple-800 text-[10px] px-2 py-0.5 rounded-full font-semibold"
//             title={`This step runs only if Source = "${requiredSource}"`}
//           >
//             üîó Source: {requiredSource}
//           </span>
//         )}
//       </div>

//       {/* üîò Buttons + BIGGER source handles (no connection status UI) */}
//       <div className="flex flex-col gap-2">
//         {buttons.map((btn, index) => {
//           const text = (btn.text || "").trim() || `Button ${index + 1}`;

//           return (
//             <div
//               key={`${text}-${index}`}
//               className="relative bg-purple-100 text-purple-800 text-xs px-3 py-1 rounded shadow-sm"
//               title={text}
//             >
//               <div className="pr-6 text-center select-none">üîò {text}</div>

//               {/* Right source handle (enlarged hit area) */}
//               <Handle
//                 type="source"
//                 position={Position.Right}
//                 id={text} // keep equal to button text for your mapping
//                 title={`Drag to connect: ${text}`}
//                 aria-label={`Connect from ${text}`}
//                 style={{
//                   background: "#9333ea",
//                   right: "-10px",
//                   top: "50%",
//                   transform: "translateY(-50%)",
//                   width: 16,
//                   height: 16,
//                   border: "2px solid #fff",
//                   borderRadius: 9999,
//                   boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
//                   cursor: "crosshair",
//                 }}
//               />
//               {/* Invisible larger hotspot to make grabbing easier */}
//               <div
//                 style={{
//                   position: "absolute",
//                   right: -18,
//                   top: "50%",
//                   transform: "translateY(-50%)",
//                   width: 36,
//                   height: 28,
//                   background: "transparent",
//                   pointerEvents: "none",
//                 }}
//               />
//             </div>
//           );
//         })}
//       </div>

//       {/* üü£ Fallback source if no buttons */}
//       {buttons.length === 0 && (
//         <Handle
//           type="source"
//           position={Position.Bottom}
//           id="default"
//           title="Drag to connect"
//           style={{
//             background: "#9333ea",
//             width: 16,
//             height: 16,
//             border: "2px solid #fff",
//             borderRadius: 9999,
//             boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
//           }}
//         />
//       )}

//       {/* üîµ Incoming target (bigger & centered) */}
//       <Handle
//         type="target"
//         position={Position.Top}
//         id="incoming"
//         title="Drop a connection here"
//         style={{
//           background: "#9333ea",
//           width: 16,
//           height: 16,
//           border: "2px solid #fff",
//           borderRadius: 9999,
//           boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
//         }}
//       />
//     </div>
//   );
// }

// import React, { useEffect } from "react";
// import { Handle, Position } from "@xyflow/react";
// import { X } from "lucide-react";

// export default function FlowNodeBubble({
//   id,
//   data,
//   onDelete,
//   readonly,
//   onDataChange,
//   visualDebug = false,
// }) {
//   const {
//     templateName,
//     messageBody,
//     buttons = [],
//     requiredTag,
//     requiredSource,
//     isUnreachable,
//   } = data;

//   // Keep trigger info in sync with first button (as you had)
//   useEffect(() => {
//     if (buttons.length > 0 && onDataChange) {
//       const triggerText = buttons[0]?.text || "";
//       onDataChange({
//         ...data,
//         triggerButtonText: triggerText,
//         triggerButtonType: "cta",
//       });
//     }
//     // eslint-disable-next-line react-hooks/exhaustive-deps
//   }, [buttons]);

//   return (
//     <div className="bg-white shadow-md rounded-xl border border-purple-200 w-72 p-4 relative">
//       {/* ‚ùå Delete */}
//       {!readonly && (
//         <button
//           onClick={() => onDelete(id)}
//           className="absolute top-1.5 right-1.5 text-red-500 hover:text-red-700"
//           title="Delete this step"
//           aria-label="Delete step"
//         >
//           <X size={16} />
//         </button>
//       )}

//       {/* ‚ö†Ô∏è Warning */}
//       {isUnreachable && (
//         <div
//           className="text-xs text-red-600 bg-red-100 px-2 py-0.5 rounded-full font-semibold mb-2 inline-block"
//           title="This step has no incoming trigger. It may never run."
//         >
//           ‚ö†Ô∏è Unreachable Step
//         </div>
//       )}

//       {/* üßæ Header */}
//       <div className="font-bold text-purple-700 mb-2">
//         üì¶ {templateName || "Untitled Step"}
//       </div>

//       {/* üí¨ Body (soft clamp to keep node height stable) */}
//       <div
//         className="text-sm text-gray-700 whitespace-pre-wrap mb-3"
//         style={{ maxHeight: 140, overflow: "auto" }}
//         title={messageBody}
//       >
//         üí¨ {messageBody || "Message body preview..."}
//       </div>

//       {/* üéØ Badges */}
//       <div className="flex flex-wrap gap-2 mb-2">
//         {!!requiredTag && (
//           <span
//             className="bg-yellow-100 text-yellow-800 text-[10px] px-2 py-0.5 rounded-full font-semibold"
//             title={`Only contacts with tag "${requiredTag}" will receive this step.`}
//           >
//             üéØ Tag: {requiredTag}
//           </span>
//         )}
//         {!!requiredSource && (
//           <span
//             className="bg-purple-100 text-purple-800 text-[10px] px-2 py-0.5 rounded-full font-semibold"
//             title={`This step runs only if Source = "${requiredSource}"`}
//           >
//             üîó Source: {requiredSource}
//           </span>
//         )}
//       </div>

//       {/* üîò Buttons + BIGGER source handles */}
//       <div className="flex flex-col gap-2">
//         {buttons.map((btn, index) => {
//           const text = (btn.text || "").trim() || `Button ${index + 1}`;
//           const connected = !!btn.targetNodeId;

//           return (
//             <div
//               key={`${text}-${index}`}
//               className="relative bg-purple-100 text-purple-800 text-xs px-3 py-1 rounded shadow-sm"
//               title={text}
//             >
//               <div className="pr-6 text-center select-none">
//                 üîò {text}
//                 {connected ? (
//                   <span
//                     className="ml-2 inline-flex items-center gap-1 text-[10px] text-green-700"
//                     title={`Connected ‚Üí ${btn.targetNodeId}`}
//                   >
//                     <span className="inline-block w-1.5 h-1.5 rounded-full bg-green-600" />
//                     connected
//                   </span>
//                 ) : (
//                   <span
//                     className="ml-2 inline-flex items-center gap-1 text-[10px] text-gray-600"
//                     title="Not connected yet"
//                   >
//                     <span className="inline-block w-1.5 h-1.5 rounded-full bg-gray-400" />
//                     not connected
//                   </span>
//                 )}
//               </div>

//               {/* Right source handle (enlarged hit area) */}
//               <Handle
//                 type="source"
//                 position={Position.Right}
//                 id={text} // keep equal to button text for your mapping
//                 title={`Drag to connect: ${text}`}
//                 aria-label={`Connect from ${text}`}
//                 style={{
//                   background: "#9333ea",
//                   right: "-10px",
//                   top: "50%",
//                   transform: "translateY(-50%)",
//                   width: 16,
//                   height: 16,
//                   border: "2px solid #fff",
//                   borderRadius: 9999,
//                   boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
//                   cursor: "crosshair",
//                 }}
//               />
//               {/* Invisible larger hotspot to make grabbing easier */}
//               <div
//                 title={`Drag to connect: ${text}`}
//                 style={{
//                   position: "absolute",
//                   right: -18,
//                   top: "50%",
//                   transform: "translateY(-50%)",
//                   width: 36,
//                   height: 28,
//                   // transparent but catches pointer for easier start
//                   background: "transparent",
//                   pointerEvents: "none",
//                 }}
//               />
//             </div>
//           );
//         })}
//       </div>

//       {/* üü£ Fallback source if no buttons */}
//       {buttons.length === 0 && (
//         <Handle
//           type="source"
//           position={Position.Bottom}
//           id="default"
//           title="Drag to connect"
//           style={{
//             background: "#9333ea",
//             width: 16,
//             height: 16,
//             border: "2px solid #fff",
//             borderRadius: 9999,
//             boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
//           }}
//         />
//       )}

//       {/* üîµ Incoming target (bigger & centered) */}
//       <Handle
//         type="target"
//         position={Position.Top}
//         id="incoming"
//         title="Drop a connection here"
//         style={{
//           background: "#9333ea",
//           width: 16,
//           height: 16,
//           border: "2px solid #fff",
//           borderRadius: 9999,
//           boxShadow: "0 0 0 2px rgba(147,51,234,0.25)",
//         }}
//       />

//       {/* üß™ Debug */}
//       {visualDebug && (
//         <div className="mt-3 text-[10px] text-gray-500">
//           üîó Connections:
//           <ul className="list-disc ml-4">
//             {buttons.map((btn, i) => (
//               <li key={i}>
//                 {(btn.text || "Unnamed").trim() || `Button ${i + 1}`} ‚Üí{" "}
//                 <strong>{btn.targetNodeId || "Not Connected"}</strong>
//               </li>
//             ))}
//           </ul>
//         </div>
//       )}
//     </div>
//   );
// }

// import React, { useEffect } from "react";
// import { Handle, Position } from "@xyflow/react";
// import { X } from "lucide-react";

// export default function FlowNodeBubble({
//   id,
//   data,
//   onDelete,
//   readonly,
//   onDataChange,
//   visualDebug = false,
// }) {
//   const {
//     templateName,
//     messageBody,
//     buttons = [],
//     requiredTag,
//     requiredSource,
//     isUnreachable,
//   } = data;

//   useEffect(() => {
//     if (buttons.length > 0 && onDataChange) {
//       const triggerText = buttons[0]?.text || "";
//       onDataChange({
//         ...data,
//         triggerButtonText: triggerText,
//         triggerButtonType: "cta",
//       });
//     }
//   }, [buttons, onDataChange, data]);

//   return (
//     <div className="bg-white shadow-md rounded-xl border border-purple-200 w-72 p-4 relative">
//       {/* ‚ùå Delete button */}
//       {!readonly && (
//         <button
//           onClick={() => onDelete(id)}
//           className="absolute top-1.5 right-1.5 text-red-500 hover:text-red-700"
//           title="Delete this step"
//         >
//           <X size={16} />
//         </button>
//       )}

//       {/* ‚ö†Ô∏è Visual Warning */}
//       {isUnreachable && (
//         <div
//           className="text-xs text-red-600 bg-red-100 px-2 py-0.5 rounded-full font-semibold mb-2 inline-block"
//           title="This step has no incoming trigger. It may never run."
//         >
//           ‚ö†Ô∏è Unreachable Step
//         </div>
//       )}

//       {/* üßæ Node Header */}
//       <div className="font-bold text-purple-700 mb-2">
//         üì¶ {templateName || "Untitled Step"}
//       </div>

//       {/* üí¨ Message Body */}
//       <div className="text-sm text-gray-700 whitespace-pre-wrap mb-3">
//         üí¨ {messageBody || "Message body preview..."}
//       </div>

//       {/* üéØ Conditional badges */}
//       <div className="flex flex-wrap gap-2 mb-2">
//         {requiredTag && (
//           <span
//             className="bg-yellow-100 text-yellow-800 text-[10px] px-2 py-0.5 rounded-full font-semibold"
//             title={`Only contacts with tag "${requiredTag}" will receive this step.`}
//           >
//             üéØ Tag: {requiredTag}
//           </span>
//         )}
//         {requiredSource && (
//           <span
//             className="bg-purple-100 text-purple-800 text-[10px] px-2 py-0.5 rounded-full font-semibold"
//             title={`This step runs only if Source = "${requiredSource}"`}
//           >
//             üîó Source: {requiredSource}
//           </span>
//         )}
//       </div>

//       {/* üîò Buttons with output handles */}
//       <div className="flex flex-col gap-2">
//         {buttons.map((btn, index) => (
//           <div
//             key={index}
//             className="bg-purple-100 text-purple-800 text-xs px-3 py-1 rounded shadow-sm text-center relative"
//           >
//             üîò {btn.text || "Untitled Button"}
//             <Handle
//               type="source"
//               position={Position.Right}
//               id={btn.text}
//               title={`Drag from: ${btn.text}`}
//               style={{
//                 background: "#9333ea",
//                 top: "50%",
//                 transform: "translateY(-50%)",
//                 right: "-8px",
//               }}
//             />
//           </div>
//         ))}
//       </div>

//       {/* üü£ Fallback output handle if no buttons */}
//       {buttons.length === 0 && (
//         <Handle
//           type="source"
//           position={Position.Bottom}
//           id="default"
//           style={{ background: "#9333ea" }}
//         />
//       )}

//       {/* üîµ Incoming connection target */}
//       <Handle
//         type="target"
//         position={Position.Top}
//         id="incoming"
//         style={{ background: "#9333ea" }}
//       />

//       {/* üß™ Visual Debug Info (no node ID) */}
//       {visualDebug && (
//         <div className="mt-3 text-[10px] text-gray-500">
//           üîó Connections:
//           <ul className="list-disc ml-4">
//             {buttons.map((btn, i) => (
//               <li key={i}>
//                 {btn.text || "Unnamed"} ‚Üí{" "}
//                 <strong>{btn.targetNodeId || "Not Connected"}</strong>
//               </li>
//             ))}
//           </ul>
//         </div>
//       )}
//     </div>
//   );
// }
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\components\TemplatePickerModal.jsx 
====================================================== 
 
// üìÑ File: TemplatePickerModal.jsx
import React, { useEffect, useState } from "react";
import axiosClient from "../../../api/axiosClient";
import { toast } from "react-toastify";

export default function TemplatePickerModal({ open, onClose, onSelect }) {
  const [templates, setTemplates] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!open) return;

    const fetchTemplates = async () => {
      setLoading(true);
      try {
        const res = await axiosClient.get(
          "/WhatsAppTemplateFetcher/get-template-all"
        );
        if (res.data.success) {
          const validTemplates = (res.data.templates || []).filter(
            t => !!t.name
          );
          setTemplates(validTemplates);
          if (validTemplates.length === 0)
            toast.warn("‚ö†Ô∏è No valid templates found");
        } else {
          toast.error("‚ùå Failed to load templates");
        }
      } catch (err) {
        console.error("‚ùå Error fetching templates:", err);
        toast.error("‚ùå Error fetching templates");
      } finally {
        setLoading(false);
      }
    };

    fetchTemplates();
  }, [open]);

  if (!open) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-40 z-50 flex items-center justify-center">
      <div className="bg-white w-full max-w-xl rounded-xl shadow-lg p-6 overflow-y-auto max-h-[90vh]">
        <h2 className="text-xl font-semibold text-purple-700 mb-4">
          üì¶ Select WhatsApp Template
        </h2>

        {loading ? (
          <p>Loading templates...</p>
        ) : templates.length === 0 ? (
          <p className="text-gray-500">No templates available</p>
        ) : (
          <div className="space-y-4">
            {templates.map((tpl, idx) => {
              const hasImageHeader =
                Array.isArray(tpl.components) &&
                tpl.components.some(
                  c => c.type === "HEADER" && c.format === "IMAGE"
                );

              const templateType = hasImageHeader
                ? "image_template"
                : "text_template";

              return (
                <div
                  key={idx}
                  className="border p-4 rounded cursor-pointer hover:bg-gray-50"
                  onClick={() =>
                    onSelect({
                      name: tpl.name,
                      type: templateType,
                      body: tpl.body,
                      buttons: tpl.buttonParams || [],
                    })
                  }
                >
                  <div className="font-bold text-purple-600">{tpl.name}</div>
                  <div className="text-sm text-gray-700 mt-1 whitespace-pre-wrap">
                    {tpl.body}
                  </div>
                  {tpl.buttonParams?.length > 0 && (
                    <div className="mt-2 flex gap-2 flex-wrap">
                      {tpl.buttonParams.map((btn, i) => (
                        <span
                          key={i}
                          className="bg-purple-100 text-purple-800 text-xs px-3 py-1 rounded-full"
                        >
                          {btn.text}
                        </span>
                      ))}
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        )}

        <div className="mt-6 text-right">
          <button
            onClick={onClose}
            className="text-sm px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
}
 
 
====================================================== 
FILE: D:\xbytechat\xbytechat-ui\src\pages\CTAFlowVisualBuilder\components\edges\SmartLabeledEdge.jsx 
====================================================== 
 
import React from "react";
import {
  BaseEdge,
  EdgeLabelRenderer,
  getSmoothStepPath,
  MarkerType,
} from "@xyflow/react";

/**
 * SmartLabeledEdge
 * - Shows button text as label
 * - If nodes are horizontally close and label is long, it renders the label vertically
 * - Supports selection and your purple style
 *
 * Optional: props.data?.labelVertical = true forces vertical label
 */
export default function SmartLabeledEdge(props) {
  const {
    id,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    style,
    markerEnd = { type: MarkerType.ArrowClosed, color: "#9333ea" },
    label,
    selected,
    data,
  } = props;

  const [edgePath, labelX, labelY] = getSmoothStepPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
  });

  // Heuristic: long label + nodes are close horizontally => use vertical
  const dx = Math.abs(targetX - sourceX);
  const longLabel = String(label || "").length > 12;
  const vertical = data?.labelVertical ?? (longLabel && dx < 220);

  return (
    <>
      <BaseEdge
        id={id}
        path={edgePath}
        markerEnd={markerEnd}
        style={{ stroke: "#9333ea", strokeWidth: selected ? 2 : 1.5, ...style }}
      />

      {label && (
        <EdgeLabelRenderer>
          <div
            style={{
              position: "absolute",
              transform: `translate(-50%, -50%) translate(${labelX}px, ${labelY}px)`,
              pointerEvents: "all",
            }}
          >
            <div
              title={label}
              style={{
                // vertical when needed
                writingMode: vertical ? "vertical-rl" : "horizontal-tb",
                textOrientation: vertical ? "mixed" : "upright",

                background: "#fff",
                padding: "4px 6px",
                borderRadius: 6,
                border: "1px solid #e5e7eb",
                fontSize: 10,
                color: "#374151",
                lineHeight: 1.1,
                maxHeight: vertical ? 140 : "none",
                maxWidth: vertical ? 18 : 180,
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: vertical ? "normal" : "nowrap",
                boxShadow: "0 1px 2px rgba(0,0,0,0.06)",
              }}
            >
              {label}
            </div>
          </div>
        </EdgeLabelRenderer>
      )}
    </>
  );
}
 
 
